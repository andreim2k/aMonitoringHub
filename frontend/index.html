<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@MonitoringHub - Real-time Weather Monitoring</title>

  <!-- Chart.js 2.x for better Safari compatibility -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js"></script>

  <style>
    /* Simple inline styles - no external dependencies */
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0b0a1e 0%, #231f47 50%, #1b1b2e 100%);
      color: white;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .card {
      background: linear-gradient(135deg, rgba(20, 18, 35, 0.95) 0%, rgba(35, 30, 70, 0.9) 50%, rgba(25, 25, 45, 0.95) 100%);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 20px;
      margin: 20px 0;
      border: none;
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }

    @media (max-width: 768px) {
      .charts-grid {
        grid-template-columns: 1fr;
      }
    }

    .stat-card {
      background: linear-gradient(135deg, rgba(20, 18, 35, 0.95) 0%, rgba(35, 30, 70, 0.9) 50%, rgba(25, 25, 45, 0.95) 100%);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 20px;
      border: none;
      text-align: center;
    }

    .stat-value {
      font-size: 2.5rem;
      font-weight: bold;
      color: #90caf9;
      margin: 10px 0;
    }

    .stat-label {
      font-size: 0.9rem;
      color: #b3b3b3;
      margin-bottom: 5px;
    }

    .stat-subtitle {
      font-size: 0.8rem;
      color: #888;
    }

    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .metric-value.status-online { color: #4caf50 !important; }
    .metric-value.status-offline { color: #f44336 !important; }
    .metric-value.status-checking {
      color: #ff9800 !important;
      animation: pulse 1.5s infinite;
    }
    .status-connecting {
      color: #ffa726;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .header {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      text-align: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .temperature-display {
      font-size: 4rem;
      font-weight: bold;
      color: #90caf9;
      text-align: center;
      margin: 30px 0;
    }

    .error {
      background: rgba(244, 67, 54, 0.2);
      border: 1px solid rgba(244, 67, 54, 0.5);
      padding: 15px;
      border-radius: 8px;
      margin: 20px 0;
    }

    .loading {
      text-align: center;
      padding: 40px;
      font-size: 1.2rem;
      color: #b3b3b3;
    }

    .btn {
      background: linear-gradient(135deg, #90caf9 0%, #64b5f6 100%);
      color: #000;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      margin: 5px;
    }

    .btn:hover {
      background: linear-gradient(135deg, #64b5f6 0%, #42a5f5 100%);
      transform: translateY(-1px);
    }

    .chart-container {
      position: relative;
      height: 300px;
      border-radius: 8px;
      padding: 10px;
    }

    /* Spinner Animation */
    .spinner {
      border: 3px solid rgba(144, 202, 249, 0.3);
      border-top: 3px solid #90caf9;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .spinner-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #90caf9;
    }

    .spinner-text {
      margin-top: 10px;
      font-size: 0.9rem;
      color: #90caf9;
    }

    /* Row-based Layout Styles */
    .metrics-row, .charts-row {
      display: flex;
      margin-bottom: 20px;
      gap: 20px;
      flex-wrap: wrap;
    }

    .metrics-row {
      justify-content: center;
    }

    .charts-row {
      justify-content: center;
    }

    .stats-row {
      justify-content: center;
    }

    .metric-card {
      background: transparent;
      border: none;
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      min-width: 140px;
      flex: 1;
      max-width: 200px;
    }
    .metric-card-disabled {
      background: transparent;
      border: none;
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      min-width: 140px;
      flex: 1;
      max-width: 200px;
    }
    .stat-card {
      min-width: 0;
      
    }

    .temperature-card {
      border-left: 4px solid #90caf9;
    }

    .humidity-card {
      border-left: 4px solid #ff9800;
    }

    .chart-card {
      background: transparent;
      border: none;
      border-radius: 12px;
      padding: 20px;
      flex: 1;
      min-width: 300px;
    }

    .chart-card h3 {
      margin: 0 0 15px 0;
      color: #e0e0e0;
      font-size: 1.1rem;
      text-align: center;
    }

    /* Electricity Meter Card - Compact styling */
    .electricity-card {
      background: transparent;
      border: none;
      border-radius: 12px;
      padding: 20px;
      width: fit-content;
      max-width: 400px;
      margin: 0 auto;
      text-align: center;
    }

    .electricity-card h3 {
      margin: 0 0 15px 0;
      color: #e0e0e0;
      font-size: 1.1rem;
      text-align: center;
    }

    .electricity-container {
      justify-content: center;
    }

    .metric-icon {
      font-size: 2rem;
      margin-bottom: 8px;
    }

    .metric-label {
      display: flex; align-items: center; gap: 8px;
    }
    .unit-badge { display:inline-block; padding:2px 6px; font-size: 0.75rem; border-radius: 8px; background: rgba(255,255,255,0.1); color:#b3b3b3; }
    .metric-label {
      display: flex; align-items: center; gap: 8px;
      font-size: 0.9rem;
      color: #b3b3b3;
      margin-bottom: 5px;
    }
    .metric-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffffff;
      margin-bottom: 3px;
    }
    .metric-timestampUnix {
      font-size: 0.7rem;
      color: #888;
    }

    .metric-value {
      transition: color 0.2s ease-in-out;
    }
    .metric-value.ok { color: #66bb6a; }
    .metric-value.warn { color: #ffa726; }
    .metric-value.bad { color: #ef5350; }

    .metric-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffffff;
      margin-bottom: 3px;
    }

    .metric-timestampUnix {
      font-size: 0.7rem;
      color: #888;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .metrics-row:nth-child(n+3), .charts-row {
        flex-direction: column;
        gap: 15px;
      }

      .stats-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
      }

      .metric-card, .metric-card-disabled, .chart-card, .electricity-card {
        max-width: none;
        min-width: auto;
      }

      .electricity-container {
        justify-content: center;
      }
    }

    @media (max-width: 300px) {
      .stats-row {
        grid-template-columns: 1fr;
      }
    }

    .chart-header {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 15px;
    }

    .chart-title {
      font-size: 1.2rem;
      font-weight: bold;
      color: #90caf9;
    }

    .humidity-display {
      font-size: 2.8rem;
      font-weight: bold;
      color: #81c784;
      text-align: center;
      margin: 15px 0;
    }

    .weather-metrics {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .weather-metrics .card {
      flex: 1;
      min-width: 250px;
      max-width: 350px;
    }

    
    .icon { display:inline-block; vertical-align:middle; opacity: 0.9; }
    .metric-icon { display:flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:10px; background: linear-gradient(180deg, rgba(255,255,255,0.25), rgba(255,255,255,0.08)); box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 6px 20px rgba(0,0,0,0.25); margin-bottom: 8px; }

    /* Glass theme */
    .glass {
      background: linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(16px) saturate(120%);
      -webkit-backdrop-filter: blur(16px) saturate(120%);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.30), inset 0 1px 0 rgba(255,255,255,0.25);
    }

    .metric-card, .metric-card-disabled, .stat-card, .chart-card, .electricity-card { position: relative; overflow:hidden; }
    .metric-card::after, .metric-card-disabled::after, .stat-card::after, .chart-card::after, .electricity-card::after {
      content: ""; position:absolute; inset:0; pointer-events:none;
      background: radial-gradient(1200px 400px at -10% -20%, rgba(255,255,255,0.08), transparent 60%),
                  radial-gradient(800px 300px at 110% 120%, rgba(255,255,255,0.06), transparent 60%);
      mix-blend-mode: screen;
    }

    .metric-card, .metric-card-disabled, .stat-card { padding: 18px; }
    .metric-label { font-weight: 600; color: #d9d9e3; letter-spacing: 0.2px; }
    .metric-value { font-size: 1.6rem; font-weight: 800; letter-spacing: 0.3px; }
    .metric-timestampUnix { margin-top: 6px; color: #9aa0a6; font-size: 0.78rem; }

    .metric-card:hover, .stat-card:hover, .chart-card:hover, .electricity-card:hover {
      transform: translateY(-2px);
      transition: transform 140ms ease, box-shadow 140ms ease;
      box-shadow: 0 14px 40px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.25);
    }

    /* Responsive grid */
    .metrics-row, .charts-row { display: grid; gap: 16px; }
    .metrics-row { grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); margin-bottom: 18px; }
    .charts-row { grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); margin-bottom: 18px; }

    @media (min-width: 1200px) {
      .metrics-row { grid-template-columns: repeat(3, 1fr); }
    }
    @media (max-width: 760px) {
      .metric-value { font-size: 1.4rem; }
      .charts-row { grid-template-columns: 1fr; }
    }

    /* Unify card background via .glass class */
    .metric-card, .metric-card-disabled, .stat-card { background: none; border: none; }
    .chart-card, .electricity-card { background: none; border: none; }

    .focus-ring:focus { outline: 2px solid rgba(255,255,255,0.35); outline-offset: 2px; }

/* Responsive/mobile fixes and alignment */
.metric-card, .stat-card { min-width: 0; display: grid; grid-template-rows: auto auto auto; row-gap: 6px; }
.metric-card .metric-icon, .metric-card .metric-label { display: inline-flex; align-items: center; }
.metric-card .metric-icon { margin-bottom: 0; }
.metric-card .metric-label { margin-left: 8px; }
.metric-card .metric-value { align-self: start; }
.metric-card .metric-timestampUnix { align-self: start; }

.metric-card-disabled, .stat-card { min-width: 0; display: grid; grid-template-rows: auto auto auto; row-gap: 6px; }
.metric-card-disabled .metric-icon, .metric-card .metric-label { display: inline-flex; align-items: center; }
.metric-card-disabled .metric-icon { margin-bottom: 0; }
.metric-card-disabled .metric-label { margin-left: 8px; }
.metric-card-disabled .metric-value { align-self: start; }
.metric-card-disabled .metric-timestampUnix { align-self: start; }

/* Ensure uniform padding on small screens */
@media (max-width: 600px) {
  .container { padding: 10px; }
  .metrics-row { grid-template-columns: 1fr; gap: 12px; }
  .charts-row { grid-template-columns: 1fr; gap: 12px; }
  .metric-card, .metric-card-disabled, .stat-card { padding: 14px; }
}

/* Tablet two columns */
@media (min-width: 600px) and (max-width: 1024px) {
  .metrics-row { grid-template-columns: repeat(2, 1fr); }
}


/* Mobile: show three cards per row for triple rows (temp/humidity/pressure/CO2) */
@media (max-width: 600px) {
  .metrics-row.triple-row { grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; }
  .metrics-row.triple-row .metric-card,
  .metrics-row.triple-row .stat-card { padding: 10px; }
  .metrics-row.triple-row .metric-label { font-size: 0.95rem; }
  .metrics-row.triple-row .metric-value { font-size: 1.2rem; }
  .metrics-row.triple-row .metric-timestampUnix { font-size: 0.7rem; }
  .metrics-row.triple-row .metric-icon { width: 24px; height: 24px; }
}


/* Center content within metric cards */
.metric-card, .stat-card { display: flex !important; flex-direction: column; align-items: center; text-align: center; }
.metric-card .metric-icon { margin: 0 0 8px 0; align-self: center; }
.metric-card .metric-label { margin-left: 0 !important; display: flex; align-items: center; gap: 8px; justify-content: center; width: 100%; }
.metric-card .metric-value { align-self: center; }
.metric-card .metric-timestampUnix { align-self: center; }

.metric-card-disabled, .stat-card { display: flex !important; flex-direction: column; align-items: center; text-align: center; }
.metric-card-disabled .metric-icon { margin: 0 0 8px 0; align-self: center; }
.metric-card-disabled .metric-label { margin-left: 0 !important; display: flex; align-items: center; gap: 8px; justify-content: center; width: 100%; }
.metric-card-disabled .metric-value { align-self: center; }
.metric-card-disabled .metric-timestampUnix { align-self: center; }
/* Ensure badges sit nicely when centered */
.unit-badge { align-self: center; }


  /* popup charts */
  .chart-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 9999; }
  .chart-modal { width: min(92vw, 680px); height: min(70vh, 440px); background: linear-gradient(135deg, rgba(20,18,35,.98) 0%, rgba(35,30,70,.95) 50%, rgba(25,25,45,.98) 100%); border-radius: 14px; padding: 16px; box-shadow: 0 12px 40px rgba(0,0,0,.5); position: relative; display: flex; flex-direction: column; }
  .chart-modal h3 { margin: 0 0 8px 0; color: #e0e0e0; font-size: 1rem; text-align: center; }
  .chart-modal .close-btn { position: absolute; top: 8px; right: 10px; background: transparent; border: none; color: #ccc; font-size: 20px; cursor: pointer; }
  .chart-canvas-wrap { position: relative; flex: 1; min-height: 240px; }
  .chart-popover { position: fixed; display: none; pointer-events: none; z-index: 9998; width: 320px; height: 200px; background: rgba(20,18,35,.96); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 8px; box-shadow: 0 10px 30px rgba(0,0,0,.4); }
  .chart-popover h4 { margin: 0 0 4px 0; font-size: .9rem; color: #e0e0e0; text-align: center; }
  .chart-popover .chart-canvas-wrap { width: 100%; height: calc(100% - 22px); }
  @media (max-width: 600px) { .chart-popover { width: 280px; height: 180px; } }

  
  /* pair grid tweak */
  @media (min-width: 600px) { .metrics-row { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
  @media (min-width: 1100px) { .metrics-row { grid-template-columns: repeat(2, minmax(0, 1fr)); } }


  /* compact mobile two-up overrides */
  .chart-popover { display: none !important; }
  @media (max-width: 420px) {
    .container { padding: 8px; }
    .metrics-row { grid-template-columns: 1fr; gap: 10px; }
    .metric-card, .stat-card { padding: 12px; }
    .metric-label { font-size: 1rem; }
    .metric-value { font-size: 1.25rem; }
    .metric-timestampUnix { font-size: 0.72rem; }
    .icon { width: 18px; height: 18px; }
  }
  @media (min-width: 421px) and (max-width: 600px) {
    .metrics-row { grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .metric-card, .metric-card-disabled, .stat-card { padding: 12px; }
    .metric-label { font-size: 1.05rem; }
    .metric-value { font-size: 1.35rem; }
    .metric-timestampUnix { font-size: 0.76rem; }
  }

  </style>
<style id="no-hover-status-readings">
/* Conservative approach: Only disable hover effects for Status and Readings cards */


.electricity-card:hover,
.electricity-card:active {
    transform: none !important;
    box-shadow: inherit !important;
    background: inherit !important;
    transition: none !important;
}
</style>
<style id="kill-pressed-effect">
/* KILL PRESSED BUTTON EFFECT FOR STATUS AND READINGS CARDS */

/* Force these cards to never move or change appearance */
</style>
</head>

<body>
  <div class="header">
    <h1>@MonitoringHub</h1>
    <p style="font-style: italic; color: #888; font-size: 0.9em;">Environmental sensors & climate insights</p>
    <div id="lastReadingTime" style="margin-top:8px;color:#90caf9;font-size:1.0rem;font-weight:600;">Last reading time: --</div>
    <!-- Connection status removed - using sensor status instead -->
  </div>

  <div class="container">
      <!-- Row 1: Sensors Status & Total Readings -->
      <div class="metrics-row">
        <div class="metric-card-disabled glass">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Status" role="img"><path fill="currentColor" d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg></div>
          <div class="metric-label">Sensors Status</div>
          <div class="metric-value status-checking" id="sensorStatus">Checking...</div>
        </div>
        <div class="metric-card-disabled glass">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Readings" role="img"><path fill="currentColor" d="M3 5h18v2H3zm0 6h12v2H3zm0 6h18v2H3z"/></svg></div>
          <div class="metric-label">Total Readings</div>
          <div class="metric-value" id="dataCount">--</div>
        </div>
      </div>


      <!-- Row 2: Temperature with Min/Max -->
      <!-- Row 2: Temperature & Pressure -->
      <div class="metrics-row">
<div class="metric-card glass temperature-card">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Temperature" role="img"><path fill="currentColor" d="M14 14.76V5a2 2 0 10-4 0v9.76A4 4 0 1014 14.76zM12 2a3 3 0 013 3v9.18a5 5 0 11-6 0V5a3 3 0 013-3z"/></svg></div>
          <div class="metric-label">Temperature <span class="unit-badge">°C</span></div>
          <div class="metric-value" id="currentTemp">--°C</div>
        </div>
<div class="metric-card glass">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Pressure" role="img"><path fill="currentColor" d="M12 2a10 10 0 1010 10A10 10 0 0012 2zm1 5h-2v6l5 3 1-1.73-4-2.27z"/></svg></div>
          <div class="metric-label">Pressure <span class="unit-badge">hPa</span></div>
          <div class="metric-value" id="currentPressure">-- hPa</div>
        </div>
      </div>

      <!-- Row 3: Humidity & CO₂ -->
      <div class="metrics-row">
<div class="metric-card glass humidity-card">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Humidity" role="img"><path fill="currentColor" d="M12 2s7 7.58 7 12a7 7 0 11-14 0c0-4.42 7-12 7-12z"/></svg></div>
          <div class="metric-label">Humidity <span class="unit-badge">%</span></div>
          <div class="metric-value" id="currentHumidity">--%</div>
        </div>
<div class="metric-card glass">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="CO2" role="img"><path fill="currentColor" d="M7 7h3v3H7zm7 0h3v3h-3zM7 14h10v3H7z"/></svg></div>
          <div class="metric-label">CO₂ <span class="unit-badge">ppm</span></div>
          <div class="metric-value" id="currentCO2">-- ppm</div>
          <div class="metric-timestampUnix" id="airNH3">NH₃: -- ppm</div>
          <div class="metric-timestampUnix" id="airAlcohol">Alcohol: -- ppm</div>
          <div class="stat-subtitle" id="airQualityStatus" style="margin-top:6px; font-weight:600;">--</div>
        </div>
      </div>
<!-- Row 6: Electricity Meter - Compact Card -->
      <div class="charts-row electricity-container">
        <div class="electricity-card glass">
          <h3>Electricity Meter</h3>
          <div style="position: relative; width: 320px; height: 240px; margin: 0 auto 15px; overflow: hidden;">
            <img id="webcamImage" style="display: none; object-fit: cover; width: 100%; height: 100%;" />
            <div id="webcamLoading" class="spinner-container" style="display: flex;">
              <div class="spinner"></div>
              <div class="spinner-text">Capturing image...</div>
            </div>
            <div id="webcamPlaceholder" style="display: none; align-items: center; justify-content: center; width: 100%; height: 100%; background: rgba(255,255,255,0.1); color: #888; font-size: 0.9rem;">
              📷 Capture failed
            </div>
          </div>
          <div style="text-align: center; width: 100%; margin-bottom: 15px;">
            <div class="em-controls" style="display:flex; flex-direction:column; gap:10px; align-items:center; justify-content:center; margin: 0 auto 10px;">
              <div style="display:flex; align-items:center; gap:10px;">
                <label for="flashToggle" style="color:#b3b3b3; font-size:0.9rem;">Flash</label>
                <label style="position:relative; display:inline-block; width:46px; height:24px;">
                  <input id="flashToggle" type="checkbox" checked style="opacity:0; width:0; height:0;">
                  <span class="slider" style="position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background:#777; transition:.2s; border-radius:24px;"></span>
                  <span class="knob" style="position:absolute; left:2px; top:2px; width:20px; height:20px; background:#fff; border-radius:50%; transition:.2s;"></span>
                </label>
              </div>
              <div style="display:flex; align-items:center; gap:10px; width:260px;">
                <label for="gainSlider" style="color:#b3b3b3; font-size:0.9rem;">Gain</label>
                <input id="gainSlider" type="range" min="0" max="10" step="1" value="2" style="flex:1; accent-color:#4caf50;">
                <span id="gainValue" class="unit-badge">2</span>
              </div>
            </div>
            <button id="captureSettingsBtn" class="btn" style="margin: 5px; background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%); display: none;">Snapshot</button>
            <button id="ocrBtn" class="btn" style="margin: 5px; background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%); display: none;">🔍 Read Index No.</button>
          </div>
          <div style="text-align: center; width: 100%;">
            <div id="ocrIndex" style="font-size: 1.5rem; font-weight: bold; color: #888; margin-bottom: 8px;">Index: -----</div>
            <div id="ocrStatus" style="font-size: 0.9rem; color: #888;"></div>
          </div>
        </div>
      </div>
    </div>


    <!-- Error Display -->
    <div id="errorDisplay" style="display: none;"></div>

    <!-- Loading Display -->
    <div id="loadingDisplay" class="loading" style="display: none;">
      Loading temperature data...
    </div>

    <!-- Footer -->
    <footer style="text-align: center; padding-top: 0p; color: #888; font-size: 0.8rem; margin-top: 0px;">
      <p>@MonitoringHub &copy; 2025. All rights reserved.</p>
    </footer>
  </div>


    <!-- Popup containers -->
    <div id="chartModalOverlay" class="chart-modal-overlay" role="dialog" aria-modal="true">
      <div class="chart-modal">
        <button class="close-btn" id="chartModalClose" aria-label="Close">×</button>
        <h3 id="chartModalTitle">History</h3>
        <div class="chart-canvas-wrap"><canvas id="chartModalCanvas"></canvas></div>
      </div>
    </div>
    <div id="hoverPopover" class="chart-popover" aria-hidden="true">
      <h4 id="hoverPopoverTitle">History</h4>
      <div class="chart-canvas-wrap"><canvas id="hoverPopoverCanvas"></canvas></div>
    </div>

  <script>
    // Global state
    let currentData = {
      temperature: null,
      humidity: null,
      timestampUnix: null,
      humidityTimestamp: null,
      sensorType: null,
      stats: { minimum: null, maximum: null, average: null, count: 0, min_timestamp: null, max_timestamp: null },
      humidityStats: { minimum: null, maximum: null, average: null, count: 0, min_timestamp: null, max_timestamp: null },
      pressureStats: { minimum: null, maximum: null, average: null, count: 0, min_timestamp: null, max_timestamp: null },
      airQualityStats: { minimum: null, maximum: null, average: null, count: 0, min_timestamp: null, max_timestamp: null },
      history: [],
      humidityHistory: [],
      connected: false,
      pressureHistory: [],
      airQualityHistory: [],
      nh3_ppm: null,
      alcohol_ppm: null,
      pressure_hpa: null,
      pressureTimestamp: null,
      co2_ppm: null,
      airStatus: null,
      airTimestamp: null
    };

    let eventSource = null;
    let historyChart = null;
    let historyHumidityChart = null;

    // Utility functions

    // Timezone-aware formatting (Europe/Bucharest) using epoch seconds when available
    const BUCHAREST_FMT = new Intl.DateTimeFormat('ro-RO', { timeZone: 'Europe/Bucharest', dateStyle: 'short', timeStyle: 'medium' });
    function formatBucharest(ts) {
      if (ts === null || ts === undefined) return 'No data';
      let d;
      if (typeof ts === 'number') {
        d = new Date(ts * 1000);
      } else {
        let str = String(ts);
        if (str.indexOf('T') === -1 && str.indexOf(' ') > -1) str = str.replace(' ', 'T');
        if (!(/[zZ]|[\+\-]\d{2}:?\d{2}$/.test(str))) str += 'Z';
        d = new Date(str);
      }
      if (isNaN(d.getTime())) return 'No data';
      const opts = { timeZone: 'Europe/Bucharest' };
      const dateStr = new Intl.DateTimeFormat('ro-RO', { day:'2-digit', month:'2-digit', year:'numeric', ...opts }).format(d);
      const timeStr = new Intl.DateTimeFormat('ro-RO', { hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false, ...opts }).format(d);
      const tzMinutes = new Date(d.toLocaleString('en-US', opts)).getTimezoneOffset();
      const tzAbbr = (tzMinutes <= -180) ? 'EEST' : 'EET';
      return `${dateStr}, ${timeStr} ${tzAbbr}`;
    }

    function formatTemperature(value) {
      if (value === null || value === undefined) return '--°C';
      return parseFloat(value).toFixed(1) + '°C';
    }

    
    function formatPressure(value) {
      if (value === null || value === undefined) return '-- hPa';
      return parseFloat(value).toFixed(1) + ' hPa';
    }

    function formatCO2(value) {
      if (value === null || value === undefined) return '-- ppm';
      return parseFloat(value).toFixed(0) + ' ppm';
    }

    function setSeverity(el, level) {
  if (!el) return;
  el.classList.remove('ok','warn','bad');
  if (level) el.classList.add(level);
}

function severityFor(metric, value) {
  if (value == null) return null;
  switch (metric) {
    case 'temp':
      if (value < 18) return 'warn';
      if (value > 27) return 'bad';
      return 'ok';
    case 'humidity':
      if (value < 30) return 'warn';
      if (value > 60) return 'warn';
      return 'ok';
    case 'pressure':
      if (value < 990) return 'warn';
      if (value > 1030) return 'warn';
      return 'ok';
    case 'co2':
      if (value > 1000) return 'bad';
      if (value > 800) return 'warn';
      return 'ok';
    default: return null;
  }
}

function formatHumidity(value) {
      if (value === null || value === undefined) return '--%';
      return parseFloat(value).toFixed(1) + '%';
    }

    function showError(message) {
      const errorDiv = document.getElementById('errorDisplay');
      errorDiv.innerHTML = '<div class="error"><strong>Error:</strong> ' + message + '</div>';
      errorDiv.style.display = 'block';
      setTimeout(function() {
        errorDiv.style.display = 'none';
      }, 5000);
    }

    function updateConnectionStatus(status, text) {
      // Legacy function - now handled by updateSensorStatus
      currentData.connected = (status === 'online');
      updateDisplay(); // Trigger display update to reflect sensor status
    }

    function updateSensorStatus(status) {
      const sensorStatusEl = document.getElementById('sensorStatus');

      if (status === 'checking') {
        sensorStatusEl.textContent = 'Checking...';
        sensorStatusEl.className = 'metric-value status-checking';
        currentData.connected = false;
      } else if (status === 'online') {
        sensorStatusEl.textContent = 'Online';
        sensorStatusEl.className = 'metric-value status-online';
        currentData.connected = true;
      } else {
        sensorStatusEl.textContent = 'Offline';
        sensorStatusEl.className = 'metric-value status-offline';
        currentData.connected = false;
      }
    }
    function updateUnifiedTimestamp() {
      const lastReadingEl = document.getElementById('lastReadingTime');
      
      // Find the most recent timestamp from all sensors
      let latestTimestamp = null;
      const timestamps = [
        currentData.timestamp,
        currentData.humidityTimestamp, 
        currentData.pressureTimestamp,
        currentData.airTimestamp
      ].filter(ts => ts != null);
      
      if (timestamps.length > 0) {
        latestTimestamp = Math.max(...timestamps);
        lastReadingEl.textContent = 'Last reading time: ' + formatBucharest(latestTimestamp);
      } else {
        lastReadingEl.textContent = 'Last reading time: --';
      }
    }


    function updateDisplay() {
      console.log('Updating display with currentData:', currentData);

      // Update unified timestamp in header
      updateUnifiedTimestamp();

      // Update main temperature display
      var elT = document.getElementById('currentTemp'); elT.textContent = formatTemperature(currentData.temperature); setSeverity(elT, severityFor('temp', currentData.temperature));

      // Update main humidity display
      var elH = document.getElementById('currentHumidity'); elH.textContent = formatHumidity(currentData.humidity); setSeverity(elH, severityFor('humidity', currentData.humidity));

      // Update pressure display
      const pEl = document.getElementById('currentPressure');
      if (pEl) { pEl.textContent = formatPressure(currentData.pressure_hpa); setSeverity(pEl, severityFor('pressure', currentData.pressure_hpa)); }
      const ptEl = document.getElementById('pressureTimestamp');
      if (ptEl) ptEl.textContent = 'Last reading: ' + formatBucharest(currentData.pressureTimestamp);

      // Update air quality display
      const co2El = document.getElementById('currentCO2');
      if (co2El) { co2El.textContent = formatCO2(currentData.co2_ppm); setSeverity(co2El, severityFor('co2', currentData.co2_ppm)); }
      const airTsEl = document.getElementById('airTimestamp');
      
      const airStatusEl = document.getElementById('airQualityStatus');
      if (airStatusEl) {
        const status = (currentData.airStatus || '--').toString();
        airStatusEl.textContent = status;
        const sLow = status.trim().toLowerCase();
        let color = '#b3b3b3';
        if (/(excellent|excelent|great|optimal|very\s*good|best)/.test(sLow)) color = '#66bb6a';
        else if (/(good|ok|okay)/.test(sLow)) color = '#81c784';
        else if (/(moderate|fair|average)/.test(sLow)) color = '#ffa726';
        else if (/(poor|bad|high|unhealthy|alert|warning|danger|critical)/.test(sLow)) color = '#ef5350';
        airStatusEl.style.color = color;
        airStatusEl.style.fontWeight = '700';
      }
      const nh3El = document.getElementById('airNH3'); if (nh3El) nh3El.textContent = 'NH₃: ' + (currentData.nh3_ppm != null ? currentData.nh3_ppm.toFixed(1) + ' ppm' : '-- ppm');
      const alcEl = document.getElementById('airAlcohol'); if (alcEl) alcEl.textContent = 'Alcohol: ' + (currentData.alcohol_ppm != null ? currentData.alcohol_ppm.toFixed(1) + ' ppm' : '-- ppm');

      // Sensor status is now managed by updateSensorStatus() function
      // Don't update it here to avoid overriding explicit status changes

      // Update stats
      var miT = document.getElementById('minTemp'); if (miT) { miT.textContent = formatTemperature(currentData.stats.minimum); setSeverity(miT, severityFor('temp', currentData.stats.minimum)); }
      var mxT = document.getElementById('maxTemp'); if (mxT) { mxT.textContent = formatTemperature(currentData.stats.maximum); setSeverity(mxT, severityFor('temp', currentData.stats.maximum)); }
      document.getElementById('dataCount').textContent = currentData.stats.count || 0;

      // Update humidity stats
      var miH = document.getElementById('minHumidity'); if (miH) { miH.textContent = formatHumidity(currentData.humidityStats.minimum); setSeverity(miH, severityFor('humidity', currentData.humidityStats.minimum)); }
      var mxH = document.getElementById('maxHumidity'); if (mxH) { mxH.textContent = formatHumidity(currentData.humidityStats.maximum); setSeverity(mxH, severityFor('humidity', currentData.humidityStats.maximum)); }
      var mtts = document.getElementById('minTempTs'); if (mtts) mtts.textContent = formatBucharest(currentData.stats.min_timestamp);
      var mxts = document.getElementById('maxTempTs'); if (mxts) mxts.textContent = formatBucharest(currentData.stats.max_timestamp);
      var mhts = document.getElementById('minHumidityTs'); if (mhts) mhts.textContent = formatBucharest(currentData.humidityStats.min_timestamp);
      var mHxTs = document.getElementById('maxHumidityTs'); if (mHxTs) mHxTs.textContent = formatBucharest(currentData.humidityStats.max_timestamp);
      var mpts = document.getElementById('minPressureTs'); if (mpts) mpts.textContent = formatBucharest(currentData.pressureStats.min_timestamp);
      var mpxts = document.getElementById('maxPressureTs'); if (mpxts) mpxts.textContent = formatBucharest(currentData.pressureStats.max_timestamp);
      var mcts = document.getElementById('minCO2Ts'); if (mcts) mcts.textContent = formatBucharest(currentData.airQualityStats.min_timestamp);
      var mcxts = document.getElementById('maxCO2Ts'); if (mcxts) mcxts.textContent = formatBucharest(currentData.airQualityStats.max_timestamp);

      // Update pressure stats
      var minP = document.getElementById('minPressure'); if (minP) { minP.textContent = formatPressure(currentData.pressureStats.minimum); setSeverity(minP, severityFor('pressure', currentData.pressureStats.minimum)); }
      var maxP = document.getElementById('maxPressure'); if (maxP) { maxP.textContent = formatPressure(currentData.pressureStats.maximum); setSeverity(maxP, severityFor('pressure', currentData.pressureStats.maximum)); }

      // Update CO2 stats
      var minC = document.getElementById('minCO2'); if (minC) { minC.textContent = formatCO2(currentData.airQualityStats.minimum); setSeverity(minC, severityFor('co2', currentData.airQualityStats.minimum)); }
      var maxC = document.getElementById('maxCO2'); if (maxC) { maxC.textContent = formatCO2(currentData.airQualityStats.maximum); setSeverity(maxC, severityFor('co2', currentData.airQualityStats.maximum)); }
    }

    function initCharts() {
  // No-op: history canvases removed; charts now shown via hover/click popups.
}




    function updateHistoryChart() {
      if (!historyChart || currentData.history.length === 0) return;

      const sortedHistory = currentData.history.slice().sort(function(a, b) {
        return a.timestampUnix - b.timestampUnix;
      });

      historyChart.data.labels = sortedHistory.map(function(item) {
        return formatBucharest(item.timestampUnix);
      });

      historyChart.data.datasets[0].data = sortedHistory.map(function(item) {
        return item.temperatureC;
      });

      historyChart.update();
    }



    

    function updatePressureHistoryChart() {
      if (!window.historyPressureChart || !window.historyPressureChart.data || currentData.pressureHistory.length === 0) return;
      const sorted = currentData.pressureHistory.slice().sort(function(a,b){ return a.timestampUnix - b.timestampUnix; });
      window.historyPressureChart.data.labels = sorted.map(function(i){ return formatBucharest(i.timestampUnix); });
      window.historyPressureChart.data.datasets[0].data = sorted.map(function(i){ return i.pressureHpa; });
      window.historyPressureChart.update();
    }

    function updateCO2HistoryChart() {
      if (!window.historyCO2Chart || !window.historyCO2Chart.data || currentData.airQualityHistory.length === 0) return;
      const sorted = currentData.airQualityHistory.slice().sort(function(a,b){ return a.timestampUnix - b.timestampUnix; });
      window.historyCO2Chart.data.labels = sorted.map(function(i){ return formatBucharest(i.timestampUnix); });
      window.historyCO2Chart.data.datasets[0].data = sorted.map(function(i){ return i.co2Ppm; });
      window.historyCO2Chart.update();
    }

    function updateHumidityHistoryChart() {
      if (!historyHumidityChart || currentData.humidityHistory.length === 0) return;

      const sortedHistory = currentData.humidityHistory.slice().sort(function(a, b) {
        return a.timestampUnix - b.timestampUnix;
      });

      historyHumidityChart.data.labels = sortedHistory.map(function(item) {
        return formatBucharest(item.timestampUnix);
      });

      historyHumidityChart.data.datasets[0].data = sortedHistory.map(function(item) {
        return item.humidityPercent;
      });

      historyHumidityChart.update();
    }

    async function graphqlQuery(query) {
      console.log('GraphQL Query:', query);
      try {
        const response = await fetch('/graphql', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query: query })
        });

        console.log('GraphQL Response status:', response.status, response.statusText);

        if (!response.ok) {
          throw new Error('HTTP ' + response.status + ': ' + response.statusText);
        }

        const result = await response.json();
        console.log('GraphQL Response data:', result);

        if (result.errors && result.errors.length > 0) {
          console.error('GraphQL Errors:', result.errors);
          throw new Error('GraphQL Error: ' + result.errors.map(e => e.message).join(', '));
        }

        return result;

      } catch (error) {
        console.error('GraphQL query error:', error);
        throw new Error('Query failed: ' + error.message);
      }
    }

    async function fetchInitialDataBackground() {
      console.log('Fetching additional data in background...');
      // Don't block the UI, just enhance it when data arrives
      setTimeout(async () => {
        try {
          await fetchHistoryData();
        } catch (error) {
          console.error('Background data fetch failed:', error);
        }
      }, 100);
    }

    async function fetchHistoryData() {
      console.log('Fetching history data...');
      try {
        // Fetch current temperature
        console.log('Fetching current temperature...');
        const currentResponse = await graphqlQuery('{ currentTemperature { temperatureC timestampUnix sensorType sensorId } }');

        if (currentResponse.data && currentResponse.data.currentTemperature) {
          const temp = currentResponse.data.currentTemperature;
          currentData.temperature = temp.temperatureC;
          currentData.timestamp = temp.timestampUnix;
          currentData.sensorType = temp.sensorType;
          console.log('Current temperature loaded:', temp);
        } else {
          console.log('No current temperature data available');
        }

        // Fetch current humidity
        console.log('Fetching current humidity...');
        const humidityResponse = await graphqlQuery('{ currentHumidity { humidityPercent timestampUnix } }');

        if (humidityResponse.data && humidityResponse.data.currentHumidity) {
          const humidity = humidityResponse.data.currentHumidity;
          currentData.humidity = humidity.humidityPercent;
          currentData.humidityTimestamp = humidity.timestampUnix;
          console.log('Current humidity loaded:', humidity);
        } else {
          console.log('No current humidity data available');
        }

        // Fetch stats
        console.log('Fetching temperature statistics...');
        const statsResponse = await graphqlQuery('{ temperatureStatistics { count average minimum maximum minTimestamp maxTimestamp } }');

        if (statsResponse.data && statsResponse.data.temperatureStatistics) {
          const ts = statsResponse.data.temperatureStatistics;
          currentData.stats = {
            ...currentData.stats,
            count: ts.count, average: ts.average, minimum: ts.minimum, maximum: ts.maximum,
            min_timestamp: ts.minTimestamp || null, max_timestamp: ts.maxTimestamp || null
          };
          console.log('Temperature stats loaded:', currentData.stats);
          updateDisplay();
      updateUnifiedTimestamp();
        }

        // Fetch humidity stats
        console.log('Fetching humidity statistics...');
        const humidityStatsResponse = await graphqlQuery('{ humidityStatistics { count average minimum maximum minTimestamp maxTimestamp } }');

        if (humidityStatsResponse.data && humidityStatsResponse.data.humidityStatistics) {
          const hs = humidityStatsResponse.data.humidityStatistics;
          currentData.humidityStats = {
            ...currentData.humidityStats,
            count: hs.count,
            average: (hs.average != null ? hs.average : (hs.avg != null ? Math.round(hs.avg*100)/100 : null)),
            minimum: (hs.minimum != null ? hs.minimum : hs.min),
            maximum: (hs.maximum != null ? hs.maximum : hs.max),
            min_timestamp: hs.minTimestamp || null,
            max_timestamp: hs.maxTimestamp || null
          };
          console.log('Humidity stats loaded:', currentData.humidityStats);
          updateDisplay();

        // Fetch pressure stats
        console.log('Fetching pressure statistics...');
        try {
          const pStats = await graphqlQuery('{ pressureStatistics { count average minimum maximum minTimestamp maxTimestamp } }');
          if (pStats.data && pStats.data.pressureStatistics) {
            const ps = pStats.data.pressureStatistics;
            currentData.pressureStats = {
              ...currentData.pressureStats,
              count: ps.count, average: ps.average, minimum: ps.minimum, maximum: ps.maximum,
              min_timestamp: ps.minTimestamp || null, max_timestamp: ps.maxTimestamp || null
            };
            console.log('Pressure stats loaded:', currentData.pressureStats);
            updateDisplay();
      updateUnifiedTimestamp();
          }
        } catch (e) { console.warn('Pressure stats query failed:', e); }

        // Fetch air quality (CO2) stats
        console.log('Fetching air quality statistics...');
        try {
          const aqStats = await graphqlQuery('{ airQualityStatistics { count average minimum maximum minTimestamp maxTimestamp } }');
          if (aqStats.data && aqStats.data.airQualityStatistics) {
            const aqs = aqStats.data.airQualityStatistics;
            currentData.airQualityStats = {
              ...currentData.airQualityStats,
              count: aqs.count, average: aqs.average, minimum: aqs.minimum, maximum: aqs.maximum,
              min_timestamp: aqs.minTimestamp || null, max_timestamp: aqs.maxTimestamp || null
            };
            console.log('Air quality stats loaded:', currentData.airQualityStats);
            updateDisplay();
      updateUnifiedTimestamp();
          }
        } catch (e) { console.warn('Air quality stats query failed:', e); }

        }

        // Fetch history
        console.log('Fetching temperature history...');
        const historyResponse = await graphqlQuery('{ temperatureHistory(limit: 5000) { temperatureC timestampUnix sensorId } }');

        if (historyResponse.data && historyResponse.data.temperatureHistory) {
          currentData.history = historyResponse.data.temperatureHistory;
          console.log('Temperature history loaded:', currentData.history.length, 'points');
          updateHistoryChart();
        }

        // Fetch humidity history
        console.log('Fetching humidity history...');
        const humidityHistoryResponse = await graphqlQuery('{ humidityHistory(limit: 5000) { humidityPercent timestampUnix sensorId } }');

        // Fetch current pressure
        console.log('Fetching current pressure...');
        const curP = await graphqlQuery('{ currentPressure { pressureHpa timestampUnix } }');
        if (curP.data && curP.data.currentPressure) {
          currentData.pressure_hpa = curP.data.currentPressure.pressureHpa;
          currentData.pressureTimestamp = curP.data.currentPressure.timestampUnix;
        }

        // Fetch pressure history
        console.log('Fetching pressure history...');
        const pHist = await graphqlQuery('{ pressureHistory(limit: 5000) { pressureHpa timestampUnix } }');
        if (pHist.data && pHist.data.pressureHistory) {
          currentData.pressureHistory = pHist.data.pressureHistory.map(function(r){ return { pressureHpa: r.pressureHpa, timestampUnix: r.timestampUnix }; });
          updatePressureHistoryChart();
        }

        // Fetch current AQ
        console.log('Fetching current air quality...');
        const curAQ = await graphqlQuery('{ currentAirQuality { co2Ppm nh3Ppm alcoholPpm aqi status timestampUnix } }');
        if (curAQ.data && curAQ.data.currentAirQuality) {
          const aq = curAQ.data.currentAirQuality;
          currentData.co2_ppm = aq.co2Ppm;
          currentData.nh3_ppm = aq.nh3Ppm;
          currentData.alcohol_ppm = aq.alcoholPpm;
          currentData.airStatus = aq.status;
          currentData.airTimestamp = aq.timestampUnix;
        }

        // Fetch AQ history
        console.log('Fetching air quality history...');
        const aqHist = await graphqlQuery('{ airQualityHistory(limit: 5000) { co2Ppm nh3Ppm alcoholPpm aqi status timestampUnix } }');
        if (aqHist.data && aqHist.data.airQualityHistory) {
          currentData.airQualityHistory = aqHist.data.airQualityHistory.map(function(r){ return { co2Ppm: r.co2Ppm, timestampUnix: r.timestampUnix }; });
          updateCO2HistoryChart();
        }

        if (humidityHistoryResponse.data && humidityHistoryResponse.data.humidityHistory) {
          currentData.humidityHistory = humidityHistoryResponse.data.humidityHistory;
          console.log('Humidity history loaded:', currentData.humidityHistory.length, 'points');
          updateHumidityHistoryChart();
        }

        // Initialize real-time chart with recent data
        if (currentData.history.length > 0) {
          const recentPoints = currentData.history.slice(-10);
          recentPoints.forEach(function(reading) {
          });
        }

        // Initialize humidity charts with recent data
        if (currentData.humidityHistory.length > 0) {
          const recentHumidityPoints = currentData.humidityHistory.slice(-10);
          recentHumidityPoints.forEach(function(reading) {
          });
        }

        console.log('Initial data fetch complete, updating display...');
        updateDisplay();
      updateUnifiedTimestamp();

      } catch (error) {
        console.error('Failed to fetch initial data:', error);
        console.error('Error details:', error.message);
        showError('Failed to load initial data: ' + error.message);
      }
    }

    function connectSSE() {
      console.log('Connecting to SSE...');
      updateSensorStatus('checking');
      if (eventSource) {
        eventSource.close();
      }

      updateSensorStatus('checking');

      try {
        eventSource = new EventSource('/events');

        eventSource.onopen = function() {
          console.log('SSE connection opened');
          updateSensorStatus('online');
        };

        eventSource.onmessage = function(event) {
          console.log('SSE message received:', event.data);
          try {
            const data = JSON.parse(event.data);

            if (data.type === 'temperature_update' && data.data) {
              const tempData = data.data;
              console.log('Temperature update:', tempData);

              // Update current data
              currentData.temperature = tempData.temperature_c;
              currentData.timestamp = tempData.timestamp;
              currentData.sensorType = tempData.sensor_type;

              // Update simple stats
              if (currentData.stats.minimum == null || tempData.temperature_c < currentData.stats.minimum) {
                currentData.stats.minimum = tempData.temperature_c; currentData.stats.min_timestamp = tempData.timestamp;
              }
              if (currentData.stats.maximum == null || tempData.temperature_c > currentData.stats.maximum) {
                currentData.stats.maximum = tempData.temperature_c; currentData.stats.max_timestamp = tempData.timestamp;
              }
              currentData.stats.count++;

              // Create reading object for charts
              const reading = {
                temperatureC: tempData.temperature_c,
                timestampUnix: tempData.timestamp,
                sensorId: tempData.sensor_id
              };

              // Add to history (keep full)
              currentData.history.push(reading);
              

              // Update display and charts
              updateDisplay();
      updateUnifiedTimestamp();

            } else if (data.type === 'pressure_update' && data.data) {
              const p = data.data;
              currentData.pressure_hpa = p.pressure_hpa;
              currentData.pressureTimestamp = p.timestamp;
              if (p.pressure_hpa != null) {
                if (currentData.pressureStats.minimum == null || p.pressure_hpa < currentData.pressureStats.minimum) { currentData.pressureStats.minimum = p.pressure_hpa; currentData.pressureStats.min_timestamp = p.timestamp; }
                if (currentData.pressureStats.maximum == null || p.pressure_hpa > currentData.pressureStats.maximum) { currentData.pressureStats.maximum = p.pressure_hpa; currentData.pressureStats.max_timestamp = p.timestamp; }
                currentData.pressureStats.count = (currentData.pressureStats.count || 0) + 1;
              }
              updateDisplay();
      updateUnifiedTimestamp();

            } else if (data.type === 'air_quality_update' && data.data) {
              const aq = data.data;
              currentData.co2_ppm = aq.co2_ppm;
              currentData.nh3_ppm = aq.nh3_ppm;
              currentData.alcohol_ppm = aq.alcohol_ppm;
              currentData.airStatus = aq.status;
              currentData.airTimestamp = aq.timestamp;
              if (aq.co2_ppm != null) {
                if (currentData.airQualityStats.minimum == null || aq.co2_ppm < currentData.airQualityStats.minimum) { currentData.airQualityStats.minimum = aq.co2_ppm; currentData.airQualityStats.min_timestamp = aq.timestamp; }
                if (currentData.airQualityStats.maximum == null || aq.co2_ppm > currentData.airQualityStats.maximum) { currentData.airQualityStats.maximum = aq.co2_ppm; currentData.airQualityStats.max_timestamp = aq.timestamp; }
                currentData.airQualityStats.count = (currentData.airQualityStats.count || 0) + 1;
              }
              currentData.airQualityHistory.push({ co2Ppm: aq.co2_ppm, timestampUnix: aq.timestamp });
              
              updateDisplay();
      updateUnifiedTimestamp();

            } else if (data.type === 'humidity_update' && data.data) {
              const humidityData = data.data;
              console.log('Humidity update:', humidityData);

              // Update current humidity data
              currentData.humidity = humidityData.humidity_percent;
              currentData.humidityTimestamp = humidityData.timestamp;

              // Update simple humidity stats
              if (currentData.humidityStats.minimum == null || humidityData.humidity_percent < currentData.humidityStats.minimum) {
                currentData.humidityStats.minimum = humidityData.humidity_percent; currentData.humidityStats.min_timestamp = humidityData.timestamp;
              }
              if (currentData.humidityStats.maximum == null || humidityData.humidity_percent > currentData.humidityStats.maximum) {
                currentData.humidityStats.maximum = humidityData.humidity_percent; currentData.humidityStats.max_timestamp = humidityData.timestamp;
              }
              currentData.humidityStats.count++;

              // Create reading object for charts
              const reading = {
                humidityPercent: humidityData.humidity_percent,
                timestampUnix: humidityData.timestamp,
                sensorId: humidityData.sensor_id
              };

              // Add to history (keep full)
              currentData.humidityHistory.push(reading);
              

              // Update display and charts
              updateDisplay();
      updateUnifiedTimestamp();

            }

          } catch (error) {
            console.error('Error parsing SSE data:', error);
          }
        };

        eventSource.onerror = function(error) {
          console.error('SSE error:', error);
          console.log('SSE readyState:', eventSource.readyState);
          updateSensorStatus('offline');

          // Attempt to reconnect after 3 seconds
          setTimeout(function() {
            if (eventSource.readyState === EventSource.CLOSED) {
              console.log('Attempting to reconnect SSE...');
              connectSSE();
            }
          }, 3000);
        };

      } catch (error) {
        console.error('Failed to create SSE connection:', error);
        updateSensorStatus('offline');
        updateDisplay();
      updateUnifiedTimestamp();
      }
    }

    // Initialize the application
    
async function initialize() {
      console.log('Initializing application...');
      try {
        // Initialize charts first
        initCharts();

        // Connect SSE immediately for instant data
        connectSSE();

        // Fetch additional data in background (don't await)
        fetchInitialDataBackground();

      } catch (error) {
        console.error('Initialization failed:', error);
        showError('Application initialization failed: ' + error.message);
      }
    }

    // Start the application when page loads
    document.addEventListener('DOMContentLoaded', initialize);

    
  
    // Automatic Webcam Capture on Page Load
    let latestWebcamOverrides = null;

    // UI: make flash toggle and gain slider visible and dynamic
    function __renderFlashToggle() {
      const t = document.getElementById('flashToggle');
      if (!t) return;
      const wrap = t.parentElement;
      const track = wrap && wrap.querySelector('.slider');
      const knob = wrap && wrap.querySelector('.knob');
      const on = !!t.checked;
      if (track) track.style.background = on ? "#4caf50" : "#777";
      if (knob) knob.style.transform = on ? "translateX(22px)" : "translateX(0)";
    }
    function __bindControlsUI() {
      const t = document.getElementById('flashToggle');
      if (t) { t.addEventListener('change', __renderFlashToggle); __renderFlashToggle(); }
      const slider = document.getElementById('gainSlider');
      const valueEl = document.getElementById('gainValue');
      const renderGain = () => { if (slider && valueEl) valueEl.textContent = String(slider.value); };
      if (slider) { slider.addEventListener('input', renderGain); renderGain(); }
    }
    document.addEventListener('DOMContentLoaded', __bindControlsUI); // { gain: number, flash: boolean } set by Capture with settings
    function captureWebcamImage() {
      const img = document.getElementById("webcamImage");
      const loading = document.getElementById("webcamLoading");
      const placeholder = document.getElementById("webcamPlaceholder");
      const ocrBtn = document.getElementById("ocrBtn");
      const statusEl = document.getElementById("ocrStatus");
      
      // Show loading
      loading.style.display = "flex";
      placeholder.style.display = "none";
      img.style.display = "none";
      
      // statusEl.textContent = "Capturing image..."; // Removed
      statusEl.style.color = "#ffa726";
      
      fetch("/webcam/capture", {
        method: "POST",
        headers: {"Content-Type": "application/json"}
      })
      .then(response => response.json())
      .then(data => {
        loading.style.display = "none";
        
        if (data.success && data.image) {
          img.src = data.image;
          img.style.display = "block";
          ocrBtn.style.display = "inline-block";
          const capSetBtn = document.getElementById("captureSettingsBtn");
          if (capSetBtn) capSetBtn.style.display = "inline-block";
          statusEl.textContent = "Image loaded - Ready for Reading Index";
          statusEl.style.color = "#4caf50";
        } else {
          placeholder.style.display = "flex";
          placeholder.innerHTML = "❌ Capture failed<br><small>" + (data.error || "Unknown error") + "</small>";
          statusEl.textContent = "Capture failed";
          statusEl.style.color = "#f44336";
        }
      })
      .catch(error => {
        loading.style.display = "none";
        placeholder.style.display = "flex";
        placeholder.innerHTML = "❌ Connection error";
        statusEl.textContent = "Network error";
        statusEl.style.color = "#f44336";
      });
    }
    
    // Capture with settings button handler
    (function(){
      const captureSettingsBtn = document.getElementById("captureSettingsBtn");
      if (captureSettingsBtn) {
        captureSettingsBtn.addEventListener("click", function() {
          const img = document.getElementById("webcamImage");
          const loading = document.getElementById("webcamLoading");
          const placeholder = document.getElementById("webcamPlaceholder");
          const statusEl = document.getElementById("ocrStatus");
          const gainSlider = document.getElementById("gainSlider");
          const gainVal = Number.isFinite(parseInt(gainSlider?.value, 10)) ? parseInt(gainSlider.value, 10) : 2;
          const flashToggle = document.getElementById("flashToggle");
          const flashVal = !!(flashToggle && flashToggle.checked);
          latestWebcamOverrides = { gain: gainVal, flash: flashVal };
          // Show loading
          loading.style.display = "flex";
          placeholder.style.display = "none";
          img.style.display = "none";
          statusEl.style.color = "#ffa726";
          statusEl.textContent = "Capturing with settings...";
          fetch("/webcam/capture", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(latestWebcamOverrides)
          })
          .then(r => r.json())
          .then(data => {
            loading.style.display = "none";
            if (data.success && data.image) {
              img.src = data.image;
              img.style.display = "block";
              statusEl.textContent = "Snapshot captured - Ready for Reading Index";
              statusEl.style.color = "#4caf50";
            } else {
              placeholder.style.display = "flex";
              placeholder.innerHTML = "❌ Capture failed<br><small>" + (data.error || "Unknown error") + "</small>";
              statusEl.textContent = "Capture with settings failed";
              statusEl.style.color = "#f44336";
            }
          })
          .catch(err => {
            loading.style.display = "none";
            placeholder.style.display = "flex";
            placeholder.innerHTML = "❌ Connection error";
            statusEl.textContent = "Network error during capture";
            statusEl.style.color = "#f44336";
          });
        });
      }
    })();

    // Manual Index Reading Function
    document.getElementById("ocrBtn").addEventListener("click", function() {
      const indexEl = document.getElementById("ocrIndex");
      const statusEl = document.getElementById("ocrStatus");
      const ocrBtn = document.getElementById("ocrBtn");
      
      // Clean up index first and disable button
      indexEl.textContent = "Index: -----";
      indexEl.style.color = "#888";
      ocrBtn.disabled = true;
      ocrBtn.textContent = "🔍 Reading...";
      statusEl.textContent = "Reading meter index...";
      statusEl.style.color = "#ffa726";
      
      // Use only the latest captured settings (if available)
      const fetchOptions = { method: 'POST', headers: { 'Content-Type': 'application/json' } };
      if (latestWebcamOverrides) { fetchOptions.body = JSON.stringify(latestWebcamOverrides); }

      fetch("/webcam/ocr", fetchOptions)
      .then(response => response.json())
      .then(data => {
        // Re-enable button
        ocrBtn.disabled = false;
        ocrBtn.textContent = "🔍 Read Index No.";
        
        if (data.success && data.index !== "-----") {
          indexEl.textContent = "Index: " + data.index;
          indexEl.style.color = "#4caf50";
          statusEl.textContent = data.engine + " - Success";
          statusEl.style.color = "#4caf50";
        } else {
          indexEl.textContent = "Index: -----";
          indexEl.style.color = "#f44336";
          statusEl.textContent = (data.error || "Reading index failed");
          statusEl.style.color = "#f44336";
        }
      })
      .catch(error => {
        ocrBtn.disabled = false;
        ocrBtn.textContent = "🔍 Read Index No.";
        indexEl.textContent = "Index: -----";
        indexEl.style.color = "#f44336";
        statusEl.textContent = "Reading index request failed";
        statusEl.style.color = "#f44336";
      });
    });
    
    // Auto-capture image when page loads (immediately)
    setTimeout(() => {
      captureWebcamImage();
    }, 100);


    // === Popup charts logic ===
    let modalChart = null; let popoverChart = null; let hoverHideTimer = null;

    const chartColors = {
      temp: { border: '#66bb6a', bg: 'rgba(102,187,106,0.15)' },
      humidity:{ border: '#9c27b0', bg: 'rgba(156,39,176,0.15)' },
      pressure:{ border: '#ffa726', bg: 'rgba(255,167,38,0.15)' },
      co2:{ border: '#ef5350', bg: 'rgba(239,83,80,0.15)' }
    };

    async function ensureHistory(kind) {
      // If there is already history loaded, skip
      if (kind === 'temp' && currentData.history && currentData.history.length) return;
      if (kind === 'humidity' && currentData.humidityHistory && currentData.humidityHistory.length) return;
      if (kind === 'pressure' && currentData.pressureHistory && currentData.pressureHistory.length) return;
      if (kind === 'co2' && currentData.airQualityHistory && currentData.airQualityHistory.length) return;
      try {
        if (kind === 'temp') {
          const r = await graphqlQuery('{ temperatureHistory(limit: 5000) { temperatureC timestampUnix } }');
          if (r.data && r.data.temperatureHistory) currentData.history = r.data.temperatureHistory;
        } else if (kind === 'humidity') {
          const r = await graphqlQuery('{ humidityHistory(limit: 5000) { humidityPercent timestampUnix } }');
          if (r.data && r.data.humidityHistory) currentData.humidityHistory = r.data.humidityHistory;
        } else if (kind === 'pressure') {
          const r = await graphqlQuery('{ pressureHistory(limit: 5000) { pressureHpa timestampUnix } }');
          if (r.data && r.data.pressureHistory) currentData.pressureHistory = r.data.pressureHistory.map(i=>({pressureHpa:i.pressureHpa,timestampUnix:i.timestampUnix}));
        } else if (kind === 'co2') {
          const r = await graphqlQuery('{ airQualityHistory(limit: 5000) { co2Ppm timestampUnix } }');
          if (r.data && r.data.airQualityHistory) currentData.airQualityHistory = r.data.airQualityHistory.map(i=>({co2Ppm:i.co2Ppm,timestampUnix:i.timestampUnix}));
        }
      } catch (e) { console.warn('ensureHistory failed for', kind, e); }
    }

    function chartDataFor(kind) {
      let labels = [], data = [], c = chartColors[kind] || {border:'#90caf9', bg:'rgba(144,202,249,0.15)'};
      if (kind === 'temp') {
        const arr = (currentData.history||[]).slice().sort((a,b)=>a.timestampUnix - b.timestampUnix); // Show all history data
        labels = arr.map(i=>formatBucharest(i.timestampUnix));
        data = arr.map(i=>i.temperatureC);
        return { labels, datasets: [{ label: 'Temperature (°C)', data, borderColor: c.border, backgroundColor: c.bg, borderWidth: 2, fill: true, pointRadius: 1 }] };
      }
      if (kind === 'humidity') {
        const arr = (currentData.humidityHistory||[]).slice().sort((a,b)=>a.timestampUnix - b.timestampUnix); // Show all history data
        labels = arr.map(i=>formatBucharest(i.timestampUnix));
        data = arr.map(i=>i.humidityPercent);
        return { labels, datasets: [{ label: 'Humidity (%)', data, borderColor: c.border, backgroundColor: c.bg, borderWidth: 2, fill: true, pointRadius: 1 }] };
      }
      if (kind === 'pressure') {
        const arr = (currentData.pressureHistory||[]).slice().sort((a,b)=>a.timestampUnix - b.timestampUnix); // Show all history data
        labels = arr.map(i=>formatBucharest(i.timestampUnix));
        data = arr.map(i=>i.pressureHpa);
        return { labels, datasets: [{ label: 'Pressure (hPa)', data, borderColor: c.border, backgroundColor: c.bg, borderWidth: 2, fill: true, pointRadius: 1 }] };
      }
      if (kind === 'co2') {
        const arr = (currentData.airQualityHistory||[]).slice().sort((a,b)=>a.timestampUnix - b.timestampUnix); // Show all history data
        labels = arr.map(i=>formatBucharest(i.timestampUnix));
        data = arr.map(i=>i.co2Ppm);
        return { labels, datasets: [{ label: 'CO₂ (ppm)', data, borderColor: c.border, backgroundColor: c.bg, borderWidth: 2, fill: true, pointRadius: 1 }] };
      }
      return { labels: [], datasets: [] };
    }

    function buildLineOptions() {
      return { responsive: true, maintainAspectRatio: false, legend: { display: false }, scales: { xAxes: [{ gridLines: { color: 'rgba(255,255,255,0.1)' }, ticks: { fontColor: '#b3b3b3', maxTicksLimit: 8 }}], yAxes: [{ gridLines: { color: 'rgba(255,255,255,0.1)' }, ticks: { fontColor: '#b3b3b3' } }] } };
    }

    async function showMetricChart(kind, mode, anchorEl) {
      await ensureHistory(kind);
      const ds = chartDataFor(kind);
      if (!ds.labels.length) return;

      if (mode === 'modal') {
        const overlay = document.getElementById('chartModalOverlay');
        const title = document.getElementById('chartModalTitle');
        const canvas = document.getElementById('chartModalCanvas');
        title.textContent = kind.toUpperCase() + ' History';
        overlay.style.display = 'flex';
        if (modalChart) { modalChart.destroy(); }
        modalChart = new Chart(canvas.getContext('2d'), { type: 'line', data: ds, options: buildLineOptions() });
      } else if (mode === 'hover') {
        const pop = document.getElementById('hoverPopover');
        const title = document.getElementById('hoverPopoverTitle');
        const canvas = document.getElementById('hoverPopoverCanvas');
        title.textContent = kind.toUpperCase() + ' History';
        // Position near anchor
        const r = anchorEl.getBoundingClientRect();
        const w = pop.offsetWidth || 320; const h = pop.offsetHeight || 200;
        let top = r.top - h - 8; if (top < 8) top = r.bottom + 8;
        let left = r.left + (r.width/2) - (w/2); left = Math.max(8, Math.min(left, (window.innerWidth - w - 8)));
        pop.style.top = top + 'px'; pop.style.left = left + 'px';
        pop.style.display = 'block';
        if (popoverChart) { popoverChart.destroy(); }
        popoverChart = new Chart(canvas.getContext('2d'), { type: 'line', data: ds, options: buildLineOptions() });
      }
    }

    function hideHoverPopoverSoon() {
      const pop = document.getElementById('hoverPopover');
      if (hoverHideTimer) clearTimeout(hoverHideTimer);
      hoverHideTimer = setTimeout(()=>{ pop.style.display = 'none'; if (popoverChart) { popoverChart.destroy(); popoverChart = null; } }, 250);
    }

    // Attach listeners once DOM is ready
    (function attachChartListeners(){
      function attach(id, kind) {
        const valEl = document.getElementById(id); if (!valEl) return;
        const card = valEl.closest('.metric-card'); if (!card) return;
        card.style.cursor = 'pointer';
        // hover disabled
        // hover disabled
        card.addEventListener('click', ()=> showMetricChart(kind, 'modal', card));
      }
      attach('currentTemp','temp');
      attach('currentPressure','pressure');
      attach('currentHumidity','humidity');
      attach('currentCO2','co2');

      // Modal close handlers
      const overlay = document.getElementById('chartModalOverlay');
      const closeBtn = document.getElementById('chartModalClose');
      if (overlay) overlay.addEventListener('click', (e)=>{ if (e.target === overlay) { overlay.style.display = 'none'; if (modalChart) { modalChart.destroy(); modalChart = null; } } });
      if (closeBtn) closeBtn.addEventListener('click', ()=>{ overlay.style.display = 'none'; if (modalChart) { modalChart.destroy(); modalChart = null; } });
    })();
    // === End popup charts ===

  </script>
</body>
</html>
