<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta name="version" content="1759253889">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@MonitoringHub - Real-time Weather Monitoring</title>

  <!-- Chart.js 4.x with modern features and better performance -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    /* Simple inline styles - no external dependencies */
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0b0a1e 0%, #231f47 50%, #1b1b2e 100%);
      color: white;
      min-height: 100vh;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }

    .card {
      background: linear-gradient(135deg, rgba(20, 18, 35, 0.95) 0%, rgba(35, 30, 70, 0.9) 50%, rgba(25, 25, 45, 0.95) 100%);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 20px;
      margin: 20px 0;
      border: none;
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }

    @media (max-width: 768px) {
      .charts-grid {
        grid-template-columns: 1fr;
      }
    }

    .stat-card {
      background: linear-gradient(135deg, rgba(20, 18, 35, 0.95) 0%, rgba(35, 30, 70, 0.9) 50%, rgba(25, 25, 45, 0.95) 100%);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 20px;
      border: none;
      text-align: center;
    }

    .stat-value {
      font-size: 2.5rem;
      font-weight: bold;
      color: #90caf9;
      margin: 10px 0;
    }

    .stat-label {
      font-size: 0.9rem;
      color: #b3b3b3;
      margin-bottom: 5px;
    }

    .stat-subtitle {
      font-size: 0.8rem;
      color: #888;
    }

    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .metric-value.status-online { color: #4caf50 !important; }
    .metric-value.status-offline { color: #f44336 !important; }
    .metric-value.status-checking {
      color: #ff9800 !important;
      animation: pulse 1.5s infinite;
    }
    .status-connecting {
      color: #ffa726;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .header {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      text-align: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .temperature-display {
      font-size: 4rem;
      font-weight: bold;
      color: #90caf9;
      text-align: center;
      margin: 30px 0;
    }

    .error {
      background: rgba(244, 67, 54, 0.2);
      border: 1px solid rgba(244, 67, 54, 0.5);
      padding: 15px;
      border-radius: 8px;
      margin: 20px 0;
    }

    .loading {
      text-align: center;
      padding: 40px;
      font-size: 1.2rem;
      color: #b3b3b3;
    }

    .btn {
      background: linear-gradient(135deg, #90caf9 0%, #64b5f6 100%);
      color: #000;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      margin: 5px;
    }

    .btn:hover {
      background: linear-gradient(135deg, #64b5f6 0%, #42a5f5 100%);
      transform: translateY(-1px);
    }

    .chart-container {
      position: relative;
      height: 300px;
      border-radius: 8px;
      padding: 10px;
    }

    /* Spinner Animation */
    .spinner {
      border: 3px solid rgba(144, 202, 249, 0.3);
      border-top: 3px solid #90caf9;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .spinner-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center; width: fit-content; margin: 0 auto;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #90caf9;
    }

    .spinner-text {
      margin-top: 10px;
      font-size: 0.9rem;
      color: #90caf9;
    }

    /* Row-based Layout Styles */
    .metrics-row, .charts-row {
      display: flex;
      margin-bottom: 20px;
      gap: 20px;
      flex-wrap: wrap;
    }

    .metrics-row {
      justify-content: center; width: fit-content; margin: 0 auto;
    }

    .charts-row {
      justify-content: center; width: fit-content; margin: 0 auto;
    }

    .stats-row {
      justify-content: center; width: fit-content; margin: 0 auto;
    }

    .metric-card {
      background: transparent;
      border: none;
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      
    }
    .metric-card-disabled {
      background: transparent;
      border: none;
      border-radius: 12px;
      padding: 20px;
      text-align: center;
    }
    .stat-card {
      min-width: 0;
      
    }

    .temperature-card {
      border-left: 4px solid #90caf9;
    }

    .humidity-card {
      border-left: 4px solid #ff9800;
    }

    .meter-card {
      border-left: 4px solid #42a5f5;
    }

    .chart-card {
      background: transparent;
      border: none;
      border-radius: 12px;
      padding: 20px;
      
      min-width: 300px;
    }

    .chart-card h3 {
      margin: 0 0 15px 0;
      color: #e0e0e0;
      font-size: 1.1rem;
      text-align: center;
    }

    /* Electricity Meter Card - Compact styling */
    .electricity-card {
      background: transparent;
      border: none;
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      box-sizing: border-box;
      text-align: center;
    }

    .electricity-card h3 {
      margin: 0 0 15px 0;
      color: #e0e0e0;
      font-size: 1.1rem;
      text-align: center;
    }

    .electricity-container {
      justify-content: center; width: fit-content; margin: 0 auto;
    }

    .metric-icon {
      font-size: 2rem;
      margin-bottom: 8px;
    }

    .metric-label {
      display: flex; align-items: center; gap: 8px;
    }
    .unit-badge { display:inline-block; padding:2px 6px; font-size: 0.75rem; border-radius: 8px; background: rgba(255,255,255,0.1); color:#b3b3b3; }
    .metric-label {
      display: flex; align-items: center; gap: 8px;
      font-size: 0.9rem;
      color: #b3b3b3;
      margin-bottom: 5px;
    }
    .metric-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffffff;
      margin-bottom: 3px;
    }
    .metric-timestampUnix {
      font-size: 0.7rem;
      color: #888;
    }

    .metric-value {
      transition: color 0.2s ease-in-out;
    }
    .metric-value.ok { color: #66bb6a; }
    .metric-value.warn { color: #ffa726; }
    .metric-value.bad { color: #ef5350; }

    .metric-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffffff;
      margin-bottom: 3px;
    }

    .metric-timestampUnix {
      font-size: 0.7rem;
      color: #888;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .metrics-row:nth-child(n+3), .charts-row {
        flex-direction: column;
        gap: 15px;
      }

      .stats-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
      }

      .metric-card, .metric-card-disabled, .chart-card, .electricity-card {
        max-width: none;
        min-width: auto;
      }

      .electricity-container {
        justify-content: center; width: fit-content; margin: 0 auto;
      }
    }

    @media (max-width: 300px) {
      .stats-row {
        grid-template-columns: 1fr;
      }
    }

    .chart-header {
      display: flex;
      justify-content: center; width: fit-content; margin: 0 auto;
      align-items: center;
      margin-bottom: 15px;
    }

    .chart-title {
      font-size: 1.2rem;
      font-weight: bold;
      color: #90caf9;
    }

    .humidity-display {
      font-size: 2.8rem;
      font-weight: bold;
      color: #81c784;
      text-align: center;
      margin: 15px 0;
    }

    .weather-metrics {
      display: flex;
      gap: 20px;
      justify-content: center; width: fit-content; margin: 0 auto;
      flex-wrap: wrap;
    }

    .weather-metrics .card {
      
      min-width: 250px;
      max-width: 350px;
    }

    
    .icon { display:inline-block; vertical-align:middle; opacity: 0.9; }
    .metric-icon { display:flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:10px; background: linear-gradient(180deg, rgba(255,255,255,0.25), rgba(255,255,255,0.08)); box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 6px 20px rgba(0,0,0,0.25); margin-bottom: 8px; }

    /* Glass theme */
    .glass {
      background: linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(16px) saturate(120%);
      -webkit-backdrop-filter: blur(16px) saturate(120%);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.30), inset 0 1px 0 rgba(255,255,255,0.25);
    }

    .metric-card, .metric-card-disabled, .stat-card, .chart-card, .electricity-card { position: relative; overflow:hidden; }
    .metric-card::after, .metric-card-disabled::after, .stat-card::after, .chart-card::after, .electricity-card::after {
      content: ""; position:absolute; inset:0; pointer-events:none;
      background: radial-gradient(1200px 400px at -10% -20%, rgba(255,255,255,0.08), transparent 60%),
                  radial-gradient(800px 300px at 110% 120%, rgba(255,255,255,0.06), transparent 60%);
      mix-blend-mode: screen;
    }

    .metric-card, .metric-card-disabled, .stat-card { padding: 18px; }
    .metric-label { font-weight: 600; color: #d9d9e3; letter-spacing: 0.2px; }
    .metric-value { font-size: 1.6rem; font-weight: 800; letter-spacing: 0.3px; }
    .metric-timestampUnix { margin-top: 6px; color: #9aa0a6; font-size: 0.78rem; }

    .metric-card:hover, .stat-card:hover, .chart-card:hover, .electricity-card:hover {
      transform: translateY(-2px);
      transition: transform 140ms ease, box-shadow 140ms ease;
      box-shadow: 0 14px 40px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.25);
    }

    /* Air Quality grouped card styles */
    .air-quality-card {
      border-left: 4px solid #66bb6a !important;
      transition: all 140ms ease;
      padding: 20px !important;
      width: 100% !important;
      box-sizing: border-box !important;
    }

    .air-quality-card:hover {
      border-left-color: #81c784 !important;
      transform: translateY(-3px) !important;
      box-shadow: 0 16px 48px rgba(102,187,106,0.25), inset 0 1px 0 rgba(255,255,255,0.25) !important;
    }

    @media (max-width: 600) {
      .air-quality-card {
        grid-column: span 1 !important;
        min-width: auto !important;
      }
      .air-quality-card #currentAQI {
        font-size: 2rem !important;
      }
      .electricity-card {
        grid-column: span 1 !important;
      }
    }

    .air-quality-card .gas-grid > div {
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .air-quality-card .gas-grid > div:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    /* Responsive grid */
    .metrics-row, .charts-row { display: grid; gap: 16px; }
    .metrics-row { grid-template-columns: repeat(2, 150px); margin-bottom: 18px; justify-content: center; max-width: 316px; margin-left: auto; margin-right: auto; }
    .charts-row { grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); margin-bottom: 18px; }
    @media (max-width: 600px) {
      .metric-value { font-size: 1.4rem; }
      .charts-row { grid-template-columns: 1fr; }
    }

    /* Unify card background via .glass class */
    .metric-card, .metric-card-disabled, .stat-card { background: none; border: none; }
    .chart-card, .electricity-card { background: none; border: none; }

    .focus-ring:focus { outline: 2px solid rgba(255,255,255,0.35); outline-offset: 2px; }

/* Responsive/mobile fixes and alignment */
.metric-card, .stat-card { min-width: 0; display: grid; grid-template-rows: auto auto auto; row-gap: 6px; }
.metric-card .metric-icon, .metric-card .metric-label { display: inline-flex; align-items: center; }
.metric-card .metric-icon { margin-bottom: 0; }
.metric-card .metric-label { margin-left: 8px; }
.metric-card .metric-value { align-self: start; }
.metric-card .metric-timestampUnix { align-self: start; }

.metric-card-disabled, .stat-card { min-width: 0; display: grid; grid-template-rows: auto auto auto; row-gap: 6px; }
.metric-card-disabled .metric-icon, .metric-card .metric-label { display: inline-flex; align-items: center; }
.metric-card-disabled .metric-icon { margin-bottom: 0; }
.metric-card-disabled .metric-label { margin-left: 8px; }
.metric-card-disabled .metric-value { align-self: start; }
.metric-card-disabled .metric-timestampUnix { align-self: start; }

/* Ensure uniform padding on small screens */
@media (max-width: 600px) {
  .container { padding: 10px; }
  .metrics-row { grid-template-columns: 1fr; gap: 12px; }
  .charts-row { grid-template-columns: 1fr; gap: 12px; }
  .metric-card, .metric-card-disabled, .stat-card { padding: 14px; }
}

/* Tablet two columns */
@media (min-width: 600px) and (max-width: 1024px) {
  .metrics-row { grid-template-columns: repeat(2, 1fr); }
}


/* Mobile: show three cards per row for triple rows (temp/humidity/pressure/CO2) */
@media (max-width: 600px) {
  .metrics-row.triple-row { grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; }
  .metrics-row.triple-row .metric-card,
  .metrics-row.triple-row .stat-card { padding: 10px; }
  .metrics-row.triple-row .metric-label { font-size: 0.95rem; }
  .metrics-row.triple-row .metric-value { font-size: 1.2rem; }
  .metrics-row.triple-row .metric-timestampUnix { font-size: 0.7rem; }
  .metrics-row.triple-row .metric-icon { width: 24px; height: 24px; }
}


/* Center content within metric cards */
.metric-card, .stat-card { display: flex !important; flex-direction: column; align-items: center; text-align: center; }
.metric-card .metric-icon { margin: 0 0 8px 0; align-self: center; }
.metric-card .metric-label { margin-left: 0 !important; display: flex; align-items: center; gap: 8px; justify-content: center; width: fit-content; margin: 0 auto; width: 100%; }
.metric-card .metric-value { align-self: center; }
.metric-card .metric-timestampUnix { align-self: center; }

.metric-card-disabled, .stat-card { display: flex !important; flex-direction: column; align-items: center; text-align: center; }
.metric-card-disabled .metric-icon { margin: 0 0 8px 0; align-self: center; }
.metric-card-disabled .metric-label { margin-left: 0 !important; display: flex; align-items: center; gap: 8px; justify-content: center; width: fit-content; margin: 0 auto; width: 100%; }
.metric-card-disabled .metric-value { align-self: center; }
.metric-card-disabled .metric-timestampUnix { align-self: center; }
/* Ensure badges sit nicely when centered */
.unit-badge { align-self: center; }


  /* popup charts */
  .chart-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; width: fit-content; margin: 0 auto; z-index: 9999; }
  .chart-modal { width: min(92vw, 680px); height: min(70vh, 490px); background: linear-gradient(135deg, rgba(20,18,35,.98) 0%, rgba(35,30,70,.95) 50%, rgba(25,25,45,.98) 100%); border-radius: 14px; padding: 16px; box-shadow: 0 12px 40px rgba(0,0,0,.5); position: relative; display: flex; flex-direction: column; }
  .chart-modal h3 { margin: 0 0 16px 0; color: #ffffff; font-size: 1.4rem; font-weight: 600; text-align: center; letter-spacing: 0.5px; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
  .chart-modal .close-btn { position: absolute; top: 8px; right: 10px; background: transparent; border: none; color: #ccc; font-size: 20px; cursor: pointer; }
  .chart-modal .time-period-container { display: flex; flex-direction: column; align-items: center; gap: 12px; margin: 12px auto; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 16px; padding: 16px 24px; width: fit-content; }
  .chart-modal .time-period-selector { display: flex; justify-content: center; gap: 20px; flex-wrap: nowrap; }
  .chart-modal .time-period-option { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
  .chart-modal .time-period-option input[type="radio"] { appearance: none; width: 18px; height: 18px; border: 2px solid #7cb8ff; border-radius: 50%; background: rgba(255,255,255,0.05); cursor: pointer; position: relative; flex-shrink: 0; transition: all 0.2s ease; }
  .chart-modal .time-period-option input[type="radio"]:hover { border-color: #90caf9; background: rgba(144,202,249,0.1); }
  .chart-modal .time-period-option input[type="radio"]:checked { background: linear-gradient(135deg, #64b5f6 0%, #42a5f5 100%); border-color: #64b5f6; box-shadow: 0 0 8px rgba(100,181,246,0.4); }
  .chart-modal .time-period-option input[type="radio"]:checked::after { content: ""; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 8px; height: 8px; background: white; border-radius: 50%; }
  .chart-modal .time-period-option label { color: #ffffff; font-size: 0.95rem; font-weight: 500; cursor: pointer; user-select: none; }
  .chart-modal .time-period-inputs { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }
  .chart-modal .time-period-inputs input, .chart-modal .time-period-inputs select { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.25); color: white; padding: 6px 12px; border-radius: 6px; font-size: 0.9rem; font-weight: 500; transition: all 0.2s ease; }
  .chart-modal .time-period-inputs input:hover, .chart-modal .time-period-inputs select:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.35); }
  .chart-modal .time-period-inputs input:focus, .chart-modal .time-period-inputs select:focus { outline: none; background: rgba(255,255,255,0.15); border-color: #64b5f6; box-shadow: 0 0 0 2px rgba(100,181,246,0.2); }
  .chart-modal .time-period-inputs input { width: 70px; text-align: center; }
  .chart-modal .time-period-inputs select { cursor: pointer; }
  .chart-canvas-wrap { position: relative;  min-height: 240px; }
  .chart-popover { position: fixed; display: none; pointer-events: none; z-index: 9998; width: 320px; height: 200px; background: rgba(20,18,35,.96); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 8px; box-shadow: 0 10px 30px rgba(0,0,0,.4); }
  .chart-popover h4 { margin: 0 0 4px 0; font-size: .9rem; color: #e0e0e0; text-align: center; }
  .chart-popover .chart-canvas-wrap { width: 100%; height: calc(100% - 22px); }
  @media (max-width: 600px) { .chart-popover { width: 280px; height: 180px; } }

  
  /* pair grid tweak */
  @media (min-width: 600px) { .metrics-row { grid-template-columns: repeat(2, minmax(200px, 280px)); } }
  @media (min-width: 1100px) { .metrics-row { grid-template-columns: repeat(2, minmax(200px, 280px)); } }


  /* compact mobile two-up overrides */
  .chart-popover { display: none !important; }
  @media (max-width: 420px) {
    .container { padding: 8px; }
    .metrics-row { grid-template-columns: 1fr; gap: 10px; }
    .metric-card, .stat-card { padding: 12px; }
    .metric-label { font-size: 1rem; }
    .metric-value { font-size: 1.25rem; }
    .metric-timestampUnix { font-size: 0.72rem; }
    .icon { width: 18px; height: 18px; }
  }
  @media (min-width: 421px) and (max-width: 600px) {
    .metrics-row { grid-template-columns: repeat(2, minmax(180px, 250px)); gap: 10px; }
    .metric-card, .metric-card-disabled, .stat-card { padding: 12px; }
    .metric-label { font-size: 1.05rem; }
    .metric-value { font-size: 1.35rem; }
    .metric-timestampUnix { font-size: 0.76rem; }
  }

  </style>
<style id="no-hover-status-readings">
/* Conservative approach: Only disable hover effects for Status and Readings cards */


.electricity-card:hover,
.electricity-card:active {
    transform: none !important;
    transition: none !important;
}
</style>
<style id="kill-pressed-effect">
/* KILL PRESSED BUTTON EFFECT FOR STATUS AND READINGS CARDS */

/* Force these cards to never move or change appearance */
</style>
</head>

<body>
  <div class="header">
    <h1>@MonitoringHub</h1>
    <p style="font-style: italic; color: #888; font-size: 0.9em;">Environmental sensors & climate insights</p>
    <p style="font-style: italic; color: #666; font-size: 0.85em; margin-top: 4px;">Cabanele MÃ¢nz, Nr 326, Clopotiva, RÃ¢u de Mori, Hunedoara</p>
    <div id="lastReadingTime" style="margin-top:8px;color:#90caf9;font-size:1.0rem;font-weight:600;">Last reading time: --</div>
    <!-- Connection status removed - using sensor status instead -->
  </div>
    </div>
  </div>

  <div class="container">
      <!-- Row 1-2: Sensors Status & Total Readings (top), Air Quality below (spans both) -->
      <div class="metrics-row" style="grid-template-rows: auto auto;">
        <div class="metric-card-disabled glass" style="grid-column: 1; grid-row: 1;">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Status" role="img"><path fill="currentColor" d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg></div>
          <div class="metric-label">Sensors Status</div>
          <div class="metric-value status-checking" id="sensorStatus">Checking...</div>
        </div>
        <div class="metric-card-disabled glass" style="grid-column: 2; grid-row: 1;">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Readings" role="img"><path fill="currentColor" d="M3 5h18v2H3zm0 6h12v2H3zm0 6h18v2H3z"/></svg></div>
          <div class="metric-label">Total Readings</div>
          <div class="metric-value" id="dataCount">--</div>
        </div>
        <div class="air-quality-card glass" style="cursor: pointer; grid-column: 1 / 3; grid-row: 2;" onclick="showMetricChart('co2', 'modal', this)">
          <!-- Header -->
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
            <div style="display: flex; align-items: center; gap: 10px;">
              <div class="metric-icon" style="width: 32px; height: 32px;">
                <svg class="icon" viewBox="0 0 24 24" width="24" height="24" aria-label="Air Quality" role="img">
                  <path fill="currentColor" d="M7 7h3v3H7zm7 0h3v3h-3zM7 14h10v3H7z"/>
                </svg>
              </div>
              <div>
                <div class="metric-label" style="font-size: 1.1rem; font-weight: 700; margin: 0;">Air Quality</div>
              </div>
            </div>
            <div style="font-size: 1.2rem; opacity: 0.6;">ðŸ“Š</div>
          </div>

          <!-- AQI Main Display -->
          <div style="background: rgba(102,187,106,0.15); border-radius: 12px; padding: 16px; margin-bottom: 14px; text-align: center; border: 1px solid rgba(102,187,106,0.3);">
            <div style="font-size: 0.8rem; color: #b3b3b3; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px;">Air Quality Index</div>
            <div id="currentAQI" style="font-size: 2.5rem; font-weight: 800; line-height: 1; margin-bottom: 6px; color: #66bb6a;">--</div>
            <div id="airQualityStatus" style="font-weight: 600; font-size: 0.85rem; padding: 6px 12px; border-radius: 6px; display: inline-block; background: rgba(255,255,255,0.08);">--</div>
          </div>

          <!-- Gas Readings Row -->
          <div class="gas-grid" style="display: flex; gap: 10px; justify-content: space-between; align-items: stretch;">
            <div style="background: rgba(239,83,80,0.15); border-radius: 8px; padding: 14px 10px; text-align: center; border: 1px solid rgba(239,83,80,0.3); flex: 1;">
              <div style="font-size: 0.75rem; color: #ef5350; font-weight: 600; margin-bottom: 6px;">COâ‚‚</div>
              <div id="currentCO2" class="metric-value" style="font-size: 1.25rem; font-weight: 700;">-- ppm</div>
            </div>
            <div style="background: rgba(66,165,245,0.15); border-radius: 8px; padding: 14px 10px; text-align: center; border: 1px solid rgba(66,165,245,0.3); flex: 1;">
              <div style="font-size: 0.75rem; color: #42a5f5; font-weight: 600; margin-bottom: 6px;">NHâ‚ƒ</div>
              <div id="currentNH3" class="metric-value" style="font-size: 1.25rem; font-weight: 700;">-- ppm</div>
            </div>
            <div style="background: rgba(255,167,38,0.15); border-radius: 8px; padding: 14px 10px; text-align: center; border: 1px solid rgba(255,167,38,0.3); flex: 1;">
              <div style="font-size: 0.75rem; color: #ffa726; font-weight: 600; margin-bottom: 6px;">Alcohol</div>
              <div id="currentAlcohol" class="metric-value" style="font-size: 1.25rem; font-weight: 700;">-- ppm</div>
            </div>
          </div>

          <!-- Air Quality Legend -->
          <div style="margin-top: 12px; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 8px; border: 1px solid rgba(255,255,255,0.08);">
            <div style="font-size: 0.7rem; color: #b3b3b3; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; text-align: center;">Air Quality Thresholds</div>
            <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; font-size: 0.65rem; line-height: 1.4;">
              <div style="text-align: center;">
                <div style="color: #ef5350; font-weight: 600; margin-bottom: 2px;">COâ‚‚</div>
                <div style="color: #66bb6a;">â‰¤800</div>
                <div style="color: #ffa726;">800-1000</div>
                <div style="color: #ef5350;">&gt;1000</div>
              </div>
              <div style="text-align: center;">
                <div style="color: #42a5f5; font-weight: 600; margin-bottom: 2px;">NHâ‚ƒ</div>
                <div style="color: #66bb6a;">â‰¤50</div>
                <div style="color: #ffa726;">50-100</div>
                <div style="color: #ef5350;">&gt;100</div>
              </div>
              <div style="text-align: center;">
                <div style="color: #ffa726; font-weight: 600; margin-bottom: 2px;">Alcohol</div>
                <div style="color: #66bb6a;">â‰¤100</div>
                <div style="color: #ffa726;">100-300</div>
                <div style="color: #ef5350;">&gt;300</div>
              </div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 8px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.05);">
              <div style="display: flex; align-items: center; gap: 3px;">
                <div style="width: 10px; height: 10px; border-radius: 2px; background: #66bb6a;"></div>
                <span style="font-size: 0.65rem; color: #e0e0e0;">Good</span>
              </div>
              <div style="display: flex; align-items: center; gap: 3px;">
                <div style="width: 10px; height: 10px; border-radius: 2px; background: #ffa726;"></div>
                <span style="font-size: 0.65rem; color: #e0e0e0;">Warning</span>
              </div>
              <div style="display: flex; align-items: center; gap: 3px;">
                <div style="width: 10px; height: 10px; border-radius: 2px; background: #ef5350;"></div>
                <span style="font-size: 0.65rem; color: #e0e0e0;">Bad</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Row 3: Temperature & Pressure -->
      <div class="metrics-row">
<div class="metric-card glass temperature-card">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Temperature" role="img"><path fill="currentColor" d="M14 14.76V5a2 2 0 10-4 0v9.76A4 4 0 1014 14.76zM12 2a3 3 0 013 3v9.18a5 5 0 11-6 0V5a3 3 0 013-3z"/></svg></div>
          <div class="metric-label">Temperature <span class="unit-badge">Â°C</span></div>
          <div class="metric-value" id="currentTemp">--Â°C</div>
        </div>
<div class="metric-card glass">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Pressure" role="img"><path fill="currentColor" d="M12 2a10 10 0 1010 10A10 10 0 0012 2zm1 5h-2v6l5 3 1-1.73-4-2.27z"/></svg></div>
          <div class="metric-label">Pressure <span class="unit-badge">hPa</span></div>
          <div class="metric-value" id="currentPressure">-- hPa</div>
        </div>
      </div>

      <!-- Row 4-5: Humidity & Electricity Index (top), Electricity Meter below (spans both) -->
      <div class="metrics-row" style="grid-template-rows: auto auto;">
<div class="metric-card glass humidity-card" style="grid-column: 1; grid-row: 1;">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Humidity" role="img"><path fill="currentColor" d="M12 2s7 7.58 7 12a7 7 0 11-14 0c0-4.42 7-12 7-12z"/></svg></div>
          <div class="metric-label">Humidity <span class="unit-badge">%</span></div>
          <div class="metric-value" id="currentHumidity">--%</div>
        </div>
<div class="metric-card glass meter-card" style="grid-column: 2; grid-row: 1;">
          <div class="metric-icon"><svg class="icon" viewBox="0 0 24 24" width="20" height="20" aria-label="Electricity" role="img"><path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg></div>
          <div class="metric-label">Electricity <span class="unit-badge">kWh</span></div>
          <div class="metric-value" id="currentMeterReading">----</div>
          <div class="metric-timestampUnix" id="meterTimestamp" style="font-size: 0.75rem; color: #888;">Last reading: --</div>
        </div>
        <div class="electricity-card glass" style="grid-column: 1 / 3; grid-row: 2;">
          <h3>Electricity Meter</h3>
          <div style="position: relative; width: 320px; height: 240px; margin: 0 auto 15px; overflow: hidden;">
            <img id="webcamImage" style="display: none; object-fit: cover; width: 100%; height: 100%;" />
            <div id="webcamLoading" class="spinner-container" style="display: flex;">
              <div class="spinner"></div>
              <div class="spinner-text">Capturing image...</div>
            </div>
            <div id="webcamPlaceholder" style="display: none; align-items: center; justify-content: center; width: fit-content; margin: 0 auto; width: 100%; height: 100%; background: rgba(255,255,255,0.1); color: #888; font-size: 0.9rem;">
              ðŸ“· Capture failed
            </div>
          </div>
          <div style="text-align: center; width: 100%; margin-bottom: 15px;">
            <div id="webcamControls" class="em-controls" style="display:flex; flex-direction:column; gap:10px; align-items:center; justify-content:center; margin: 0 auto 10px;">
              <div style="display:flex; align-items:center; gap:10px;">
                <label for="flashToggle" style="color:#b3b3b3; font-size:0.9rem;">Flash</label>
                <label style="position:relative; display:inline-block; width:46px; height:24px;">
                  <input id="flashToggle" type="checkbox" checked style="opacity:0; width:0; height:0;">
                  <span class="slider" style="position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background:#777; transition:.2s; border-radius:24px;"></span>
                  <span class="knob" style="position:absolute; left:2px; top:2px; width:20px; height:20px; background:#fff; border-radius:50%; transition:.2s;"></span>
                </label>
              </div>
              <div style="display:flex; align-items:center; gap:10px; width:260px;">
                <label for="gainSlider" style="color:#b3b3b3; font-size:0.9rem;">Gain</label>
                <input id="gainSlider" type="range" min="0" max="10" step="1" value="2" style="flex:1; accent-color:#4caf50;">
                <span id="gainValue" class="unit-badge">2</span>
              </div>
            </div>
            <button id="captureSettingsBtn" class="btn" style="margin: 5px auto; background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%); display: none;">Snapshot</button>
          </div>
        </div>
      </div>
    </div>


    <!-- Error Display -->
    <div id="errorDisplay" style="display: none;"></div>

    <!-- Loading Display -->
    <div id="loadingDisplay" class="loading" style="display: none;">
      Loading temperature data...
    </div>

    <!-- Footer -->
    <footer style="text-align: center; padding-top: 0p; color: #888; font-size: 0.8rem; margin-top: 0px;">
      <p>@MonitoringHub &copy; 2025. All rights reserved.</p>
    </footer>
  </div>


    <!-- Popup containers -->
    <div id="chartModalOverlay" class="chart-modal-overlay" role="dialog" aria-modal="true">
      <div class="chart-modal">
        <button class="close-btn" id="chartModalClose" aria-label="Close">Ã—</button>
        <h3 id="chartModalTitle">History</h3>
        <div class="time-period-container">
          <div class="time-period-selector">
            <div class="time-period-option">
              <input type="radio" id="periodRecent" name="chartPeriod" value="recent" checked>
              <label for="periodRecent">Recent</label>
            </div>
            <div class="time-period-option">
              <input type="radio" id="periodYear" name="chartPeriod" value="year">
              <label for="periodYear">Years</label>
            </div>
            <div class="time-period-option">
              <input type="radio" id="periodMonth" name="chartPeriod" value="month">
              <label for="periodMonth">Months</label>
            </div>
            <div class="time-period-option">
              <input type="radio" id="periodDay" name="chartPeriod" value="day">
              <label for="periodDay">Days</label>
            </div>
          </div>
          <div class="time-period-inputs" id="timePeriodInputs" style="display: none;">
            <input type="number" id="modalYearInput" placeholder="Year" min="2020" max="2030" style="display: none;">
            <select id="modalMonthInput" style="display: none;">
              <option value="1">Jan</option><option value="2">Feb</option><option value="3">Mar</option><option value="4">Apr</option>
              <option value="5">May</option><option value="6">Jun</option><option value="7">Jul</option><option value="8">Aug</option>
              <option value="9">Sep</option><option value="10">Oct</option><option value="11">Nov</option><option value="12">Dec</option>
            </select>
            <input type="number" id="modalDayInput" placeholder="Day" min="1" max="31" style="display: none;">
          </div>
        </div>
        <div class="chart-canvas-wrap"><canvas id="chartModalCanvas"></canvas></div>

        <!-- Air Quality Information (shown only for CO2 chart) -->
        <div id="airQualityInfo" style="display: none; margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.03); border-radius: 8px; font-size: 0.75rem; line-height: 1.6; color: #e0e0e0;">
          <div style="display: flex; gap: 20px; justify-content: center; margin-bottom: 6px;">
            <div><span style="color: #66bb6a; font-weight: 600;">AQI:</span> Score 1-5, lower is better</div>
            <div><span style="color: #ef5350; font-weight: 600;">COâ‚‚:</span> Ventilation indicator</div>
          </div>
          <div style="display: flex; gap: 20px; justify-content: center;">
            <div><span style="color: #42a5f5; font-weight: 600;">NHâ‚ƒ:</span> From cleaning, waste</div>
            <div><span style="color: #ffa726; font-weight: 600;">Alcohol:</span> VOCs from solvents</div>
          </div>
        </div>
      </div>
    </div>
    <div id="hoverPopover" class="chart-popover" aria-hidden="true">
      <h4 id="hoverPopoverTitle">History</h4>
      <div class="chart-canvas-wrap"><canvas id="hoverPopoverCanvas"></canvas></div>
    </div>

  <script>
    // Global state
    let currentData = {
      temperature: null,
      humidity: null,
      timestampUnix: null,
      humidityTimestamp: null,
      sensorType: null,
      stats: { minimum: null, maximum: null, average: null, count: 0, total_count: 0, min_timestamp: null, max_timestamp: null },
      humidityStats: { minimum: null, maximum: null, average: null, count: 0, min_timestamp: null, max_timestamp: null },
      pressureStats: { minimum: null, maximum: null, average: null, count: 0, min_timestamp: null, max_timestamp: null },
      airQualityStats: { minimum: null, maximum: null, average: null, count: 0, min_timestamp: null, max_timestamp: null },
      history: [],
      humidityHistory: [],
      connected: false,
      pressureHistory: [],
      airQualityHistory: [],
      meterHistory: [],
      nh3_ppm: null,
      alcohol_ppm: null,
      aqi: null,
      pressure_hpa: null,
      pressureTimestamp: null,
      co2_ppm: null,
      airStatus: null,
      airTimestamp: null
    };

    let eventSource = null;
    let historyChart = null;
    let historyHumidityChart = null;

    // Utility functions

    // Timezone-aware formatting (Europe/Bucharest) using epoch seconds when available
    const BUCHAREST_FMT = new Intl.DateTimeFormat('ro-RO', { timeZone: 'Europe/Bucharest', dateStyle: 'short', timeStyle: 'medium' });
    

    function formatTemperature(value) {
      if (value === null || value === undefined) return '--Â°C';
      return parseFloat(value).toFixed(1) + 'Â°C';
    }

    
    function formatPressure(value) {
      if (value === null || value === undefined) return '-- hPa';
      return parseFloat(value).toFixed(1) + ' hPa';
    }

    function formatCO2(value) {
      if (value === null || value === undefined) return '-- ppm';
      return parseFloat(value).toFixed(0) + ' ppm';
    }

    function setSeverity(el, level) {
  if (!el) return;
  el.classList.remove('ok','warn','bad');
  if (level) el.classList.add(level);
}

function severityFor(metric, value) {
  if (value == null) return null;
  switch (metric) {
    case 'temp':
      if (value < 18) return 'warn';
      if (value > 27) return 'bad';
      return 'ok';
    case 'humidity':
      if (value < 30) return 'warn';
      if (value > 60) return 'warn';
      return 'ok';
    case 'pressure':
      if (value < 990) return 'warn';
      if (value > 1030) return 'warn';
      return 'ok';
    case 'co2':
      if (value > 1000) return 'bad';
      if (value > 800) return 'warn';
      return 'ok';
    case 'nh3':
      // NH3 thresholds: <50 good, 50-100 warning, >100 bad
      if (value > 100) return 'bad';
      if (value > 50) return 'warn';
      return 'ok';
    case 'alcohol':
      // Alcohol vapor thresholds: <100 good, 100-300 warning, >300 bad
      if (value > 300) return 'bad';
      if (value > 100) return 'warn';
      return 'ok';
    default: return null;
  }
}

function formatHumidity(value) {
      if (value === null || value === undefined) return '--%';
      return parseFloat(value).toFixed(1) + '%';
    }

    function showError(message) {
      const errorDiv = document.getElementById('errorDisplay');
      errorDiv.innerHTML = '<div class="error"><strong>Error:</strong> ' + message + '</div>';
      errorDiv.style.display = 'block';
      setTimeout(function() {
        errorDiv.style.display = 'none';
      }, 5000);
    }

    function updateConnectionStatus(status, text) {
      // Legacy function - now handled by updateSensorStatus
      currentData.connected = (status === 'online');
      updateDisplay(); // Trigger display update to reflect sensor status
    }

    function updateSensorStatus(status) {
      const sensorStatusEl = document.getElementById('sensorStatus');

      if (status === 'checking') {
        sensorStatusEl.textContent = 'Checking...';
        sensorStatusEl.className = 'metric-value status-checking';
        currentData.connected = false;
      } else if (status === 'online') {
        sensorStatusEl.textContent = 'Online';
        sensorStatusEl.className = 'metric-value status-online';
        currentData.connected = true;
      } else {
        sensorStatusEl.textContent = 'Offline';
        sensorStatusEl.className = 'metric-value status-offline';
        currentData.connected = false;
      }
    }
    function updateUnifiedTimestamp() {
      const lastReadingEl = document.getElementById('lastReadingTime');
      
      // Find the most recent timestamp from all sensors
      let latestTimestamp = null;
      const timestamps = [
        currentData.timestamp,
        currentData.humidityTimestamp, 
        currentData.pressureTimestamp,
        currentData.airTimestamp
      ].filter(ts => ts != null);
      
      if (timestamps.length > 0) {
        latestTimestamp = Math.max(...timestamps);
        lastReadingEl.textContent = 'Last reading time: ' + new Date(latestTimestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      } else {
        lastReadingEl.textContent = 'Last reading time: --';
      }
    }




function updateDisplay() {
      console.log('Updating display with currentData:', currentData);

      // Update unified timestamp in header
      updateUnifiedTimestamp();

      // Update main temperature display
      var elT = document.getElementById('currentTemp'); elT.textContent = formatTemperature(currentData.temperature); setSeverity(elT, severityFor('temp', currentData.temperature));

      // Update main humidity display
      var elH = document.getElementById('currentHumidity'); elH.textContent = formatHumidity(currentData.humidity); setSeverity(elH, severityFor('humidity', currentData.humidity));

      // Update pressure display
      const pEl = document.getElementById('currentPressure');
      if (pEl) { pEl.textContent = formatPressure(currentData.pressure_hpa); setSeverity(pEl, severityFor('pressure', currentData.pressure_hpa)); }
      const ptEl = document.getElementById('pressureTimestamp');
      if (ptEl) ptEl.textContent = 'Last reading: ' + new Date(currentData.pressureTimestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});

      // Update air quality display - AQI with color coding
      const aqiEl = document.getElementById('currentAQI');
      if (aqiEl && currentData.aqi != null) {
        aqiEl.textContent = currentData.aqi;

        // Apply color based on AQI value
        // Standard AQI ranges: 0-50 Good (Green), 51-100 Moderate (Yellow/Orange), 101-150 Unhealthy for Sensitive (Orange), 151+ Unhealthy (Red)
        let aqiColor = '#66bb6a'; // Default green
        if (currentData.aqi > 150) {
          aqiColor = '#ef5350'; // Red - Unhealthy
        } else if (currentData.aqi > 100) {
          aqiColor = '#ff9800'; // Orange - Unhealthy for Sensitive Groups
        } else if (currentData.aqi > 50) {
          aqiColor = '#ffa726'; // Light Orange - Moderate
        }
        aqiEl.style.color = aqiColor;

        // Update the Air Quality card border-left color to match AQI color
        const aqiCard = document.querySelector('.air-quality-card');
        if (aqiCard) {
          aqiCard.style.borderLeftColor = aqiColor;
        }
      }

      // Update air quality status
      const airStatusEl = document.getElementById('airQualityStatus');
      if (airStatusEl) {
        const status = (currentData.airStatus || '--').toString();
        airStatusEl.textContent = status;
        const sLow = status.trim().toLowerCase();
        let color = '#b3b3b3';
        if (/(excellent|excelent|great|optimal|very\s*good|best)/.test(sLow)) color = '#66bb6a';
        else if (/(good|ok|okay)/.test(sLow)) color = '#81c784';
        else if (/(moderate|fair|average)/.test(sLow)) color = '#ffa726';
        else if (/(poor|bad|high|unhealthy|alert|warning|danger|critical)/.test(sLow)) color = '#ef5350';
        airStatusEl.style.color = color;
        airStatusEl.style.fontWeight = '700';
      }

      // Update individual gas readings
      const co2El = document.getElementById('currentCO2');
      if (co2El) { co2El.textContent = formatCO2(currentData.co2_ppm); setSeverity(co2El, severityFor('co2', currentData.co2_ppm)); }

      const nh3El = document.getElementById('currentNH3');
      if (nh3El) {
        nh3El.textContent = currentData.nh3_ppm != null ? currentData.nh3_ppm.toFixed(1) + ' ppm' : '-- ppm';
        setSeverity(nh3El, severityFor('nh3', currentData.nh3_ppm));
      }

      const alcEl = document.getElementById('currentAlcohol');
      if (alcEl) {
        alcEl.textContent = currentData.alcohol_ppm != null ? currentData.alcohol_ppm.toFixed(1) + ' ppm' : '-- ppm';
        setSeverity(alcEl, severityFor('alcohol', currentData.alcohol_ppm));
      }

      // Update meter reading display
      const meterEl = document.getElementById('currentMeterReading');
      const meterTsEl = document.getElementById('meterTimestamp');
      if (meterEl && currentData.meterValue != null) {
        meterEl.textContent = currentData.meterValue;
        meterEl.style.color = '#ffffff';
      }
      if (meterTsEl && currentData.meterTimestamp) {
        meterTsEl.textContent = 'Last reading: ' + new Date(currentData.meterTimestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      }

      // Sensor status is now managed by updateSensorStatus() function
      // Don't update it here to avoid overriding explicit status changes

      // Update stats
      var miT = document.getElementById('minTemp'); if (miT) { miT.textContent = formatTemperature(currentData.stats.minimum); setSeverity(miT, severityFor('temp', currentData.stats.minimum)); }
      var mxT = document.getElementById('maxTemp'); if (mxT) { mxT.textContent = formatTemperature(currentData.stats.maximum); setSeverity(mxT, severityFor('temp', currentData.stats.maximum)); }
      document.getElementById('dataCount').textContent = currentData.stats.total_count || 0;

      // Update humidity stats
      var miH = document.getElementById('minHumidity'); if (miH) { miH.textContent = formatHumidity(currentData.humidityStats.minimum); setSeverity(miH, severityFor('humidity', currentData.humidityStats.minimum)); }
      var mxH = document.getElementById('maxHumidity'); if (mxH) { mxH.textContent = formatHumidity(currentData.humidityStats.maximum); setSeverity(mxH, severityFor('humidity', currentData.humidityStats.maximum)); }
      var mtts = document.getElementById('minTempTs'); if (mtts) mtts.textContent = new Date(currentData.stats.min_timestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      var mxts = document.getElementById('maxTempTs'); if (mxts) mxts.textContent = new Date(currentData.stats.max_timestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      var mhts = document.getElementById('minHumidityTs'); if (mhts) mhts.textContent = new Date(currentData.humidityStats.min_timestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      var mHxTs = document.getElementById('maxHumidityTs'); if (mHxTs) mHxTs.textContent = new Date(currentData.humidityStats.max_timestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      var mpts = document.getElementById('minPressureTs'); if (mpts) mpts.textContent = new Date(currentData.pressureStats.min_timestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      var mpxts = document.getElementById('maxPressureTs'); if (mpxts) mpxts.textContent = new Date(currentData.pressureStats.max_timestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      var mcts = document.getElementById('minCO2Ts'); if (mcts) mcts.textContent = new Date(currentData.airQualityStats.min_timestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      var mcxts = document.getElementById('maxCO2Ts'); if (mcxts) mcxts.textContent = new Date(currentData.airQualityStats.max_timestamp * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});

      // Update pressure stats
      var minP = document.getElementById('minPressure'); if (minP) { minP.textContent = formatPressure(currentData.pressureStats.minimum); setSeverity(minP, severityFor('pressure', currentData.pressureStats.minimum)); }
      var maxP = document.getElementById('maxPressure'); if (maxP) { maxP.textContent = formatPressure(currentData.pressureStats.maximum); setSeverity(maxP, severityFor('pressure', currentData.pressureStats.maximum)); }

      // Update CO2 stats
      var minC = document.getElementById('minCO2'); if (minC) { minC.textContent = formatCO2(currentData.airQualityStats.minimum); setSeverity(minC, severityFor('co2', currentData.airQualityStats.minimum)); }
      var maxC = document.getElementById('maxCO2'); if (maxC) { maxC.textContent = formatCO2(currentData.airQualityStats.maximum); setSeverity(maxC, severityFor('co2', currentData.airQualityStats.maximum)); }
    }

    function initCharts() {
  // No-op: history canvases removed; charts now shown via hover/click popups.
}




    function updateHistoryChart() {
      if (!historyChart || currentData.history.length === 0) return;

      const sortedHistory = currentData.history.slice().sort(function(a, b) {
        return a.timestampUnix - b.timestampUnix;
      });

      historyChart.data.labels = sortedHistory.map(function(item) {
        return new Date(item.timestampUnix * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      });

      historyChart.data.datasets[0].data = sortedHistory.map(function(item) {
        return item.temperatureC;
      });

      historyChart.update();
    }



    

    function updatePressureHistoryChart() {
      if (!window.historyPressureChart || !window.historyPressureChart.data || currentData.pressureHistory.length === 0) return;
      const sorted = currentData.pressureHistory.slice().sort(function(a,b){ return a.timestampUnix - b.timestampUnix; });
      window.historyPressureChart.data.labels = sorted.map(function(i){ return new Date(i.timestampUnix * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false}); });
      window.historyPressureChart.data.datasets[0].data = sorted.map(function(i){ return i.pressureHpa; });
      window.historyPressureChart.update();
    }

    function updateCO2HistoryChart() {
      if (!window.historyCO2Chart || !window.historyCO2Chart.data || currentData.airQualityHistory.length === 0) return;
      const sorted = currentData.airQualityHistory.slice().sort(function(a,b){ return a.timestampUnix - b.timestampUnix; });
      window.historyCO2Chart.data.labels = sorted.map(function(i){ return new Date(i.timestampUnix * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false}); });

      // Update all 4 datasets
      if (window.historyCO2Chart.data.datasets.length >= 4) {
        window.historyCO2Chart.data.datasets[0].data = sorted.map(function(i){ return i.aqi; });
        window.historyCO2Chart.data.datasets[1].data = sorted.map(function(i){ return i.co2Ppm; });
        window.historyCO2Chart.data.datasets[2].data = sorted.map(function(i){ return i.nh3Ppm; });
        window.historyCO2Chart.data.datasets[3].data = sorted.map(function(i){ return i.alcoholPpm; });
      } else {
        // Fallback for old chart structure
        window.historyCO2Chart.data.datasets[0].data = sorted.map(function(i){ return i.co2Ppm; });
      }
      window.historyCO2Chart.update();
    }

    function updateHumidityHistoryChart() {
      if (!historyHumidityChart || currentData.humidityHistory.length === 0) return;

      const sortedHistory = currentData.humidityHistory.slice().sort(function(a, b) {
        return a.timestampUnix - b.timestampUnix;
      });

      historyHumidityChart.data.labels = sortedHistory.map(function(item) {
        return new Date(item.timestampUnix * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false});
      });

      historyHumidityChart.data.datasets[0].data = sortedHistory.map(function(item) {
        return item.humidityPercent;
      });

      historyHumidityChart.update();
    }

    async function graphqlQuery(query) {
      console.log('GraphQL Query:', query);
      try {
        const response = await fetch('/graphql', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query: query })
        });

        console.log('GraphQL Response status:', response.status, response.statusText);

        if (!response.ok) {
          throw new Error('HTTP ' + response.status + ': ' + response.statusText);
        }

        const result = await response.json();
        console.log('GraphQL Response data:', result);

        if (result.errors && result.errors.length > 0) {
          console.error('GraphQL Errors:', result.errors);
          throw new Error('GraphQL Error: ' + result.errors.map(e => e.message).join(', '));
        }

        return result;

      } catch (error) {
        console.error('GraphQL query error:', error);
        throw new Error('Query failed: ' + error.message);
      }
    }

    async function fetchInitialDataBackground() {
      console.log('Fetching additional data in background...');
      // Don't block the UI, just enhance it when data arrives
      setTimeout(async () => {
        try {
          await fetchHistoryData();
        } catch (error) {
          console.error('Background data fetch failed:', error);
        }
      }, 100);
    }

    async function fetchHistoryData() {
      console.log('Fetching history data...');
      try {
        // Fetch current temperature
        console.log('Fetching current temperature...');
        const currentResponse = await graphqlQuery('{ currentTemperature { temperatureC timestampUnix sensorType sensorId } }');

        if (currentResponse.data && currentResponse.data.currentTemperature) {
          const temp = currentResponse.data.currentTemperature;
          currentData.temperature = temp.temperatureC;
          currentData.timestamp = temp.timestampUnix;
          currentData.sensorType = temp.sensorType;
          console.log('Current temperature loaded:', temp);
        } else {
          console.log('No current temperature data available');
        }

        // Fetch current humidity
        console.log('Fetching current humidity...');
        const humidityResponse = await graphqlQuery('{ currentHumidity { humidityPercent timestampUnix } }');

        if (humidityResponse.data && humidityResponse.data.currentHumidity) {
          const humidity = humidityResponse.data.currentHumidity;
          currentData.humidity = humidity.humidityPercent;
          currentData.humidityTimestamp = humidity.timestampUnix;
          console.log('Current humidity loaded:', humidity);
        } else {
          console.log('No current humidity data available');
        }

        // Fetch stats
        console.log('Fetching temperature statistics...');
        const statsResponse = await graphqlQuery('{ temperatureStatistics { count totalCount average minimum maximum minTimestamp maxTimestamp } }');

        if (statsResponse.data && statsResponse.data.temperatureStatistics) {
          const ts = statsResponse.data.temperatureStatistics;
          currentData.stats = {
            ...currentData.stats,
            count: ts.count, total_count: ts.totalCount, average: ts.average, minimum: ts.minimum, maximum: ts.maximum,
            min_timestamp: ts.minTimestamp || null, max_timestamp: ts.maxTimestamp || null
          };
          console.log('Temperature stats loaded:', currentData.stats);
          updateDisplay();
      updateUnifiedTimestamp();
        }

        // Fetch humidity stats
        console.log('Fetching humidity statistics...');
        const humidityStatsResponse = await graphqlQuery('{ humidityStatistics { count average minimum maximum minTimestamp maxTimestamp } }');

        if (humidityStatsResponse.data && humidityStatsResponse.data.humidityStatistics) {
          const hs = humidityStatsResponse.data.humidityStatistics;
          currentData.humidityStats = {
            ...currentData.humidityStats,
            count: hs.count,
            average: (hs.average != null ? hs.average : (hs.avg != null ? Math.round(hs.avg*100)/100 : null)),
            minimum: (hs.minimum != null ? hs.minimum : hs.min),
            maximum: (hs.maximum != null ? hs.maximum : hs.max),
            min_timestamp: hs.minTimestamp || null,
            max_timestamp: hs.maxTimestamp || null
          };
          console.log('Humidity stats loaded:', currentData.humidityStats);
          updateDisplay();

        // Fetch pressure stats
        console.log('Fetching pressure statistics...');
        try {
          const pStats = await graphqlQuery('{ pressureStatistics { count average minimum maximum minTimestamp maxTimestamp } }');
          if (pStats.data && pStats.data.pressureStatistics) {
            const ps = pStats.data.pressureStatistics;
            currentData.pressureStats = {
              ...currentData.pressureStats,
              count: ps.count, average: ps.average, minimum: ps.minimum, maximum: ps.maximum,
              min_timestamp: ps.minTimestamp || null, max_timestamp: ps.maxTimestamp || null
            };
            console.log('Pressure stats loaded:', currentData.pressureStats);
            updateDisplay();
      updateUnifiedTimestamp();
          }
        } catch (e) { console.warn('Pressure stats query failed:', e); }

        // Fetch air quality (CO2) stats
        console.log('Fetching air quality statistics...');
        try {
          const aqStats = await graphqlQuery('{ airQualityStatistics { count average minimum maximum minTimestamp maxTimestamp } }');
          if (aqStats.data && aqStats.data.airQualityStatistics) {
            const aqs = aqStats.data.airQualityStatistics;
            currentData.airQualityStats = {
              ...currentData.airQualityStats,
              count: aqs.count, average: aqs.average, minimum: aqs.minimum, maximum: aqs.maximum,
              min_timestamp: aqs.minTimestamp || null, max_timestamp: aqs.maxTimestamp || null
            };
            console.log('Air quality stats loaded:', currentData.airQualityStats);
            updateDisplay();
      updateUnifiedTimestamp();
          }
        } catch (e) { console.warn('Air quality stats query failed:', e); }

        }

        // Fetch history
        console.log('Fetching temperature history...');
        const historyResponse = await graphqlQuery('{ temperatureHistory(limit: 5000) { temperatureC timestampUnix sensorId } }');

        if (historyResponse.data && historyResponse.data.temperatureHistory) {
          currentData.history = historyResponse.data.temperatureHistory;
          console.log('Temperature history loaded:', currentData.history.length, 'points');
          updateHistoryChart();
        }

        // Fetch humidity history
        console.log('Fetching humidity history...');
        const humidityHistoryResponse = await graphqlQuery('{ humidityHistory(limit: 5000) { humidityPercent timestampUnix sensorId } }');

        // Fetch current pressure
        console.log('Fetching current pressure...');
        const curP = await graphqlQuery('{ currentPressure { pressureHpa timestampUnix } }');
        if (curP.data && curP.data.currentPressure) {
          currentData.pressure_hpa = curP.data.currentPressure.pressureHpa;
          currentData.pressureTimestamp = curP.data.currentPressure.timestampUnix;
        }

        // Fetch pressure history
        console.log('Fetching pressure history...');
        const pHist = await graphqlQuery('{ pressureHistory(limit: 5000) { pressureHpa timestampUnix } }');
        if (pHist.data && pHist.data.pressureHistory) {
          currentData.pressureHistory = pHist.data.pressureHistory.map(function(r){ return { pressureHpa: r.pressureHpa, timestampUnix: r.timestampUnix }; });
          updatePressureHistoryChart();
        }

        // Fetch current AQ
        console.log('Fetching current air quality...');
        const curAQ = await graphqlQuery('{ currentAirQuality { co2Ppm nh3Ppm alcoholPpm aqi status timestampUnix } }');
        if (curAQ.data && curAQ.data.currentAirQuality) {
          const aq = curAQ.data.currentAirQuality;
          currentData.co2_ppm = aq.co2Ppm;
          currentData.nh3_ppm = aq.nh3Ppm;
          currentData.alcohol_ppm = aq.alcoholPpm;
          currentData.aqi = aq.aqi;
          currentData.airStatus = aq.status;
          currentData.airTimestamp = aq.timestampUnix;
        }

        // Fetch AQ history
        console.log('Fetching air quality history...');
        const aqHist = await graphqlQuery('{ airQualityHistory(limit: 5000) { co2Ppm nh3Ppm alcoholPpm aqi status timestampUnix } }');
        if (aqHist.data && aqHist.data.airQualityHistory) {
          currentData.airQualityHistory = aqHist.data.airQualityHistory.map(function(r){
            return {
              co2Ppm: r.co2Ppm,
              nh3Ppm: r.nh3Ppm,
              alcoholPpm: r.alcoholPpm,
              aqi: r.aqi,
              timestampUnix: r.timestampUnix
            };
          });
          updateCO2HistoryChart();
        }

        // Fetch current meter reading
        console.log('Fetching current meter reading...');
        const curMeter = await graphqlQuery('{ currentMeterReading { meterValue timestampUnix ocrEngine } }');
        if (curMeter.data && curMeter.data.currentMeterReading) {
          const meter = curMeter.data.currentMeterReading;
          currentData.meterValue = meter.meterValue;
          currentData.meterTimestamp = meter.timestampUnix;
          console.log('Meter reading loaded:', meter.meterValue);
        }

        if (humidityHistoryResponse.data && humidityHistoryResponse.data.humidityHistory) {
          currentData.humidityHistory = humidityHistoryResponse.data.humidityHistory;
          console.log('Humidity history loaded:', currentData.humidityHistory.length, 'points');
          updateHumidityHistoryChart();
        }

        // Initialize real-time chart with recent data
        if (currentData.history.length > 0) {
          const recentPoints = currentData.history.slice(-10);
          recentPoints.forEach(function(reading) {
          });
        }

        // Initialize humidity charts with recent data
        if (currentData.humidityHistory.length > 0) {
          const recentHumidityPoints = currentData.humidityHistory.slice(-10);
          recentHumidityPoints.forEach(function(reading) {
          });
        }

        console.log('Initial data fetch complete, updating display...');
        updateDisplay();
      updateUnifiedTimestamp();

      } catch (error) {
        console.error('Failed to fetch initial data:', error);
        console.error('Error details:', error.message);
        showError('Failed to load initial data: ' + error.message);
      }
    }

    function connectSSE() {
      console.log('Connecting to SSE...');
      updateSensorStatus('checking');
      if (eventSource) {
        eventSource.close();
      }

      updateSensorStatus('checking');

      try {
        eventSource = new EventSource('/events');

        eventSource.onopen = function() {
          console.log('SSE connection opened');
          updateSensorStatus('online');
        };

        eventSource.onmessage = function(event) {
          console.log('SSE message received:', event.data);
          try {
            const data = JSON.parse(event.data);

            if (data.type === 'temperature_update' && data.data) {
              const tempData = data.data;
              console.log('Temperature update:', tempData);

              // Update current data
              currentData.temperature = tempData.temperature_c;
              currentData.timestamp = tempData.timestamp;
              currentData.sensorType = tempData.sensor_type;

              // Update simple stats
              if (currentData.stats.minimum == null || tempData.temperature_c < currentData.stats.minimum) {
                currentData.stats.minimum = tempData.temperature_c; currentData.stats.min_timestamp = tempData.timestamp;
              }
              if (currentData.stats.maximum == null || tempData.temperature_c > currentData.stats.maximum) {
                currentData.stats.maximum = tempData.temperature_c; currentData.stats.max_timestamp = tempData.timestamp;
              }
              currentData.stats.count++;

              // Create reading object for charts
              const reading = {
                temperatureC: tempData.temperature_c,
                timestampUnix: tempData.timestamp,
                sensorId: tempData.sensor_id
              };

              // Add to history (keep full)
              currentData.history.push(reading);
              

              // Update display and charts
              updateDisplay();
      updateUnifiedTimestamp();

            } else if (data.type === 'pressure_update' && data.data) {
              const p = data.data;
              currentData.pressure_hpa = p.pressure_hpa;
              currentData.pressureTimestamp = p.timestamp;
              if (p.pressure_hpa != null) {
                if (currentData.pressureStats.minimum == null || p.pressure_hpa < currentData.pressureStats.minimum) { currentData.pressureStats.minimum = p.pressure_hpa; currentData.pressureStats.min_timestamp = p.timestamp; }
                if (currentData.pressureStats.maximum == null || p.pressure_hpa > currentData.pressureStats.maximum) { currentData.pressureStats.maximum = p.pressure_hpa; currentData.pressureStats.max_timestamp = p.timestamp; }
                currentData.pressureStats.count = (currentData.pressureStats.count || 0) + 1;
              }
              updateDisplay();
      updateUnifiedTimestamp();

            } else if (data.type === 'air_quality_update' && data.data) {
              const aq = data.data;
              currentData.co2_ppm = aq.co2_ppm;
              currentData.nh3_ppm = aq.nh3_ppm;
              currentData.alcohol_ppm = aq.alcohol_ppm;
              currentData.aqi = aq.aqi;
              currentData.airStatus = aq.status;
              currentData.airTimestamp = aq.timestamp;
              if (aq.co2_ppm != null) {
                if (currentData.airQualityStats.minimum == null || aq.co2_ppm < currentData.airQualityStats.minimum) { currentData.airQualityStats.minimum = aq.co2_ppm; currentData.airQualityStats.min_timestamp = aq.timestamp; }
                if (currentData.airQualityStats.maximum == null || aq.co2_ppm > currentData.airQualityStats.maximum) { currentData.airQualityStats.maximum = aq.co2_ppm; currentData.airQualityStats.max_timestamp = aq.timestamp; }
                currentData.airQualityStats.count = (currentData.airQualityStats.count || 0) + 1;
              }
              currentData.airQualityHistory.push({
                co2Ppm: aq.co2_ppm,
                nh3Ppm: aq.nh3_ppm,
                alcoholPpm: aq.alcohol_ppm,
                aqi: aq.aqi,
                timestampUnix: aq.timestamp
              });
              
              updateDisplay();
      updateUnifiedTimestamp();

            } else if (data.type === 'humidity_update' && data.data) {
              const humidityData = data.data;
              console.log('Humidity update:', humidityData);

              // Update current humidity data
              currentData.humidity = humidityData.humidity_percent;
              currentData.humidityTimestamp = humidityData.timestamp;

              // Update simple humidity stats
              if (currentData.humidityStats.minimum == null || humidityData.humidity_percent < currentData.humidityStats.minimum) {
                currentData.humidityStats.minimum = humidityData.humidity_percent; currentData.humidityStats.min_timestamp = humidityData.timestamp;
              }
              if (currentData.humidityStats.maximum == null || humidityData.humidity_percent > currentData.humidityStats.maximum) {
                currentData.humidityStats.maximum = humidityData.humidity_percent; currentData.humidityStats.max_timestamp = humidityData.timestamp;
              }
              currentData.humidityStats.count++;

              // Create reading object for charts
              const reading = {
                humidityPercent: humidityData.humidity_percent,
                timestampUnix: humidityData.timestamp,
                sensorId: humidityData.sensor_id
              };

              // Add to history (keep full)
              currentData.humidityHistory.push(reading);
              

              // Update display and charts
              updateDisplay();
      updateUnifiedTimestamp();

            }

          } catch (error) {
            console.error('Error parsing SSE data:', error);
          }
        };

        eventSource.onerror = function(error) {
          console.error('SSE error:', error);
          console.log('SSE readyState:', eventSource.readyState);
          updateSensorStatus('offline');

          // Attempt to reconnect after 3 seconds
          setTimeout(function() {
            if (eventSource.readyState === EventSource.CLOSED) {
              console.log('Attempting to reconnect SSE...');
              connectSSE();
            }
          }, 3000);
        };

      } catch (error) {
        console.error('Failed to create SSE connection:', error);
        updateSensorStatus('offline');
        updateDisplay();
      updateUnifiedTimestamp();
      }
    }

    // Initialize the application
    
async function initialize() {
      console.log('Initializing application...');
      try {
        // Initialize charts first
        initCharts();

        // Connect SSE immediately for instant data
        connectSSE();

        // Fetch additional data in background (don't await)
        fetchInitialDataBackground();

      } catch (error) {
        console.error('Initialization failed:', error);
        showError('Application initialization failed: ' + error.message);
      }
    }

    // Start the application when page loads
    document.addEventListener('DOMContentLoaded', initialize);

    
  
    // Automatic Webcam Capture on Page Load
    let latestWebcamOverrides = null;

    // UI: make flash toggle and gain slider visible and dynamic
    function __renderFlashToggle() {
      const t = document.getElementById('flashToggle');
      if (!t) return;
      const wrap = t.parentElement;
      const track = wrap && wrap.querySelector('.slider');
      const knob = wrap && wrap.querySelector('.knob');
      const on = !!t.checked;
      if (track) track.style.background = on ? "#4caf50" : "#777";
      if (knob) knob.style.transform = on ? "translateX(22px)" : "translateX(0)";
    }
    function __bindControlsUI() {
      const t = document.getElementById('flashToggle');
      if (t) { t.addEventListener('change', __renderFlashToggle); __renderFlashToggle(); }
      const slider = document.getElementById('gainSlider');
      const valueEl = document.getElementById('gainValue');
      const renderGain = () => { if (slider && valueEl) valueEl.textContent = String(slider.value); };
      if (slider) { slider.addEventListener('input', renderGain); renderGain(); }
    }
    document.addEventListener('DOMContentLoaded', __bindControlsUI); // { gain: number, flash: boolean } set by Capture with settings
    function captureWebcamImage() {
      const img = document.getElementById("webcamImage");
      const loading = document.getElementById("webcamLoading");
      const placeholder = document.getElementById("webcamPlaceholder");

      // Show loading
      // Hide controls and button during capture
      const controls = document.getElementById("webcamControls");
      const btn = document.getElementById("captureSettingsBtn");
      if (controls) controls.style.display = "none";
      if (btn) btn.style.display = "none";
      loading.style.display = "flex";
      placeholder.style.display = "none";
      img.style.display = "none";
      
      fetch("/webcam/capture", {
        method: "POST",
        headers: {"Content-Type": "application/json"}
      })
      .then(response => response.json())
      .then(data => {
        loading.style.display = "none";
        if (data.success && data.image) {
          img.src = data.image;
          img.style.display = "block";
          // Show controls after image loads
          const controls = document.getElementById("webcamControls");
          const btn = document.getElementById("captureSettingsBtn");
          if (controls) controls.style.display = "flex";
          if (btn) btn.style.display = "block";
          const capSetBtn = document.getElementById("captureSettingsBtn");
          if (capSetBtn) capSetBtn.style.display = "block";
        } else {
          placeholder.style.display = "flex";
          placeholder.innerHTML = "âŒ Capture failed<br><small>" + (data.error || "Unknown error") + "</small>";
          // statusEl.textContent = "Capture failed"; // Removed
          // statusEl.style.color = "#f44336"; // Removed
        }
      })
      .catch(error => {
        loading.style.display = "none";
        placeholder.style.display = "flex";
        placeholder.innerHTML = "âŒ Connection error";
        // statusEl.textContent = "Network error" + error; // Removed
        // statusEl.style.color = "#f44336"; // Removed
      });
    }


    // Capture with settings button handler
    (function(){
        console.log('I AM HEREEEEEEEEEEEEE');   
      const captureSettingsBtn = document.getElementById("captureSettingsBtn");
      if (captureSettingsBtn) {
        captureSettingsBtn.addEventListener("click", function() {
          // Hide controls and snapshot button while capturing
          const controls = document.getElementById("webcamControls");
          const btn = document.getElementById("captureSettingsBtn");
          if (controls) controls.style.display = "none";
          if (btn) btn.style.display = "none";
          
          const img = document.getElementById("webcamImage");
          const loading = document.getElementById("webcamLoading");
          const placeholder = document.getElementById("webcamPlaceholder");
          const gainSlider = document.getElementById("gainSlider");
          const gainVal = Number.isFinite(parseInt(gainSlider?.value, 10)) ? parseInt(gainSlider.value, 10) : 2;
          const flashToggle = document.getElementById("flashToggle");
          const flashVal = !!(flashToggle && flashToggle.checked);
          latestWebcamOverrides = { gain: gainVal, flash: flashVal };
          // Show loading
          loading.style.display = "flex";
          placeholder.style.display = "none";
          img.style.display = "none";
          // statusEl.style.color = "#ffa726"; // Removed
          // statusEl.textContent = "Capturing with settings..."; // Removed
          fetch("/webcam/capture", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(latestWebcamOverrides)
          })
          .then(r => r.json())
          .then(data => {
            loading.style.display = "none";
            // Show controls and snapshot button
            const controls = document.getElementById("webcamControls");
            const btn = document.getElementById("captureSettingsBtn");
            if (controls) controls.style.display = "flex";
            if (btn) btn.style.display = "block";
            if (data.success && data.image) {
              img.src = data.image;
              img.style.display = "block";
            } else {
              placeholder.style.display = "flex";
              placeholder.innerHTML = "âŒ Capture failed<br><small>" + (data.error || "Unknown error") + "</small>";
              // statusEl.textContent = "Capture with settings failed"; // Removed
              // statusEl.style.color = "#f44336"; // Removed
            }
          })
          .catch(err => {
            loading.style.display = "none";
            placeholder.style.display = "flex";
            placeholder.innerHTML = "âŒ Connection error";
            // statusEl.textContent = "Network error during capture"; // Removed
            // statusEl.style.color = "#f44336"; // Removed
          });
        });
      }
    })();

    
    
    // Auto-capture image when page loads (immediately)
    setTimeout(() => {
      captureWebcamImage();
    }, 100);

    // === Popup charts logic ===
    let modalChart = null; let popoverChart = null; let hoverHideTimer = null;

    const chartColors = {
      temp: { border: '#66bb6a', bg: 'rgba(102,187,106,0.15)' },
      humidity:{ border: '#9c27b0', bg: 'rgba(156,39,176,0.15)' },
      pressure:{ border: '#ffa726', bg: 'rgba(255,167,38,0.15)' },
      co2:{ border: '#ef5350', bg: 'rgba(239,83,80,0.15)' },
      meter:{ border: '#42a5f5', bg: 'rgba(66,165,245,0.15)' }
    };

    async function ensureHistory(kind) {
      // If there is already history loaded, skip
      if (kind === 'temp' && currentData.history && currentData.history.length) return;
      if (kind === 'humidity' && currentData.humidityHistory && currentData.humidityHistory.length) return;
      if (kind === 'pressure' && currentData.pressureHistory && currentData.pressureHistory.length) return;
      if (kind === 'co2' && currentData.airQualityHistory && currentData.airQualityHistory.length) return;
      if (kind === 'meter' && currentData.meterHistory && currentData.meterHistory.length) return;
      try {
        if (kind === 'temp') {
          const r = await graphqlQuery('{ temperatureHistory(limit: 5000) { temperatureC timestampUnix } }');
          if (r.data && r.data.temperatureHistory) currentData.history = r.data.temperatureHistory;
        } else if (kind === 'humidity') {
          const r = await graphqlQuery('{ humidityHistory(limit: 5000) { humidityPercent timestampUnix } }');
          if (r.data && r.data.humidityHistory) currentData.humidityHistory = r.data.humidityHistory;
        } else if (kind === 'pressure') {
          const r = await graphqlQuery('{ pressureHistory(limit: 5000) { pressureHpa timestampUnix } }');
          if (r.data && r.data.pressureHistory) currentData.pressureHistory = r.data.pressureHistory.map(i=>({pressureHpa:i.pressureHpa,timestampUnix:i.timestampUnix}));
        } else if (kind === 'co2') {
          const r = await graphqlQuery('{ airQualityHistory(limit: 5000) { co2Ppm nh3Ppm alcoholPpm aqi timestampUnix } }');
          if (r.data && r.data.airQualityHistory) currentData.airQualityHistory = r.data.airQualityHistory.map(i=>({co2Ppm:i.co2Ppm, nh3Ppm:i.nh3Ppm, alcoholPpm:i.alcoholPpm, aqi:i.aqi, timestampUnix:i.timestampUnix}));
        } else if (kind === 'meter') {
          const r = await graphqlQuery('{ meterHistory(limit: 5000) { meterValue timestampUnix } }');
          if (r.data && r.data.meterHistory) currentData.meterHistory = r.data.meterHistory.map(i=>({meterValue:i.meterValue,timestampUnix:i.timestampUnix}));
        }
      } catch (e) { console.warn('ensureHistory failed for', kind, e); }
    }

    function chartDataFor(kind) {
      let labels = [], data = [], c = chartColors[kind] || {border:'#90caf9', bg:'rgba(144,202,249,0.15)'};
      if (kind === 'temp') {
        const arr = (currentData.history||[]).slice().sort((a,b)=>a.timestampUnix - b.timestampUnix); // Show all history data
        labels = arr.map(i=>new Date(i.timestampUnix * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false}));
        data = arr.map(i=>i.temperatureC);
        return { labels, datasets: [{ label: 'Temperature (Â°C)', data, borderColor: c.border, backgroundColor: c.bg, borderWidth: 2, fill: true, pointRadius: 1 }] };
      }
      if (kind === 'humidity') {
        const arr = (currentData.humidityHistory||[]).slice().sort((a,b)=>a.timestampUnix - b.timestampUnix); // Show all history data
        labels = arr.map(i=>new Date(i.timestampUnix * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false}));
        data = arr.map(i=>i.humidityPercent);
        return { labels, datasets: [{ label: 'Humidity (%)', data, borderColor: c.border, backgroundColor: c.bg, borderWidth: 2, fill: true, pointRadius: 1 }] };
      }
      if (kind === 'pressure') {
        const arr = (currentData.pressureHistory||[]).slice().sort((a,b)=>a.timestampUnix - b.timestampUnix); // Show all history data
        labels = arr.map(i=>new Date(i.timestampUnix * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false}));
        data = arr.map(i=>i.pressureHpa);
        return { labels, datasets: [{ label: 'Pressure (hPa)', data, borderColor: c.border, backgroundColor: c.bg, borderWidth: 2, fill: true, pointRadius: 1 }] };
      }
      if (kind === 'co2') {
        const arr = (currentData.airQualityHistory||[]).slice().sort((a,b)=>a.timestampUnix - b.timestampUnix); // Show all history data
        labels = arr.map(i=>new Date(i.timestampUnix * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false}));

        // Create datasets for all 4 components
        const aqiData = arr.map(i=>i.aqi);
        const co2Data = arr.map(i=>i.co2Ppm);
        const nh3Data = arr.map(i=>i.nh3Ppm);
        const alcoholData = arr.map(i=>i.alcoholPpm);

        return {
          labels,
          datasets: [
            { label: 'AQI', data: aqiData, borderColor: '#66bb6a', backgroundColor: 'rgba(102,187,106,0.15)', borderWidth: 2, fill: false, pointRadius: 1, yAxisID: 'y-aqi' },
            { label: 'COâ‚‚ (ppm)', data: co2Data, borderColor: '#ef5350', backgroundColor: 'rgba(239,83,80,0.15)', borderWidth: 2, fill: false, pointRadius: 1, yAxisID: 'y-gas' },
            { label: 'NHâ‚ƒ (ppm)', data: nh3Data, borderColor: '#42a5f5', backgroundColor: 'rgba(66,165,245,0.15)', borderWidth: 2, fill: false, pointRadius: 1, yAxisID: 'y-gas' },
            { label: 'Alcohol (ppm)', data: alcoholData, borderColor: '#ffa726', backgroundColor: 'rgba(255,167,38,0.15)', borderWidth: 2, fill: false, pointRadius: 1, yAxisID: 'y-gas' }
          ]
        };
      }
      if (kind === 'meter') {
        const arr = (currentData.meterHistory||[]).slice().sort((a,b)=>a.timestampUnix - b.timestampUnix); // Show all history data
        labels = arr.map(i=>new Date(i.timestampUnix * 1000).toLocaleString("en-GB", {timeZone: "Europe/Bucharest", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false}));
        data = arr.map(i=>parseFloat(i.meterValue) || 0);
        return { labels, datasets: [{ label: 'Electricity Meter (kWh)', data, borderColor: c.border, backgroundColor: c.bg, borderWidth: 2, fill: true, pointRadius: 2 }] };
      }
      return { labels: [], datasets: [] };
    }

    function buildLineOptions(chartType) {
      // For air quality chart, use dual Y-axes
      if (chartType === 'co2') {
        return {
          responsive: true,
          maintainAspectRatio: false,
          legend: { display: true, position: 'top', labels: { fontColor: '#b3b3b3', boxWidth: 15, padding: 10 } },
          tooltips: {
            callbacks: {
              label: function(tooltipItem, data) {
                const datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
                const value = tooltipItem.yLabel;
                return datasetLabel + ': ' + value;
              },
              title: function(tooltipItems, data) {
                const label = data.labels[tooltipItems[0].index];
                return label;
              }
            }
          },
          scales: {
            xAxes: [{
              gridLines: { color: 'rgba(255,255,255,0.1)' },
              ticks: { fontColor: '#b3b3b3', maxTicksLimit: 8 }
            }],
            yAxes: [
              {
                id: 'y-aqi',
                type: 'linear',
                position: 'left',
                gridLines: { color: 'rgba(102,187,106,0.2)' },
                ticks: { fontColor: '#66bb6a', beginAtZero: true },
                scaleLabel: { display: true, labelString: 'AQI', fontColor: '#66bb6a' }
              },
              {
                id: 'y-gas',
                type: 'linear',
                position: 'right',
                gridLines: { display: false },
                ticks: { fontColor: '#b3b3b3', beginAtZero: true },
                scaleLabel: { display: true, labelString: 'ppm', fontColor: '#b3b3b3' }
              }
            ]
          }
        };
      }

      // Default options for other charts
      return {
        responsive: true,
        maintainAspectRatio: false,
        legend: { display: false },
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              const value = tooltipItem.yLabel;
              return value;
            },
            title: function(tooltipItems, data) {
              const label = data.labels[tooltipItems[0].index];
              return label;
            }
          }
        },
        scales: {
          xAxes: [{
            gridLines: { color: 'rgba(255,255,255,0.1)' },
            ticks: { fontColor: '#b3b3b3', maxTicksLimit: 8 }
          }],
          yAxes: [{
            gridLines: { color: 'rgba(255,255,255,0.1)' },
            ticks: { fontColor: '#b3b3b3' }
          }]
        }
      };
    }
    // Chart Modal Time Period Logic
    let currentChartKind = null;
    let currentModalChart = null;
    
    function updateModalInputsVisibility() {
      const selectedPeriod = document.querySelector("input[name=\"chartPeriod\"]:checked")?.value;
      const inputsContainer = document.getElementById("timePeriodInputs");
      const yearInput = document.getElementById("modalYearInput");
      const monthInput = document.getElementById("modalMonthInput");
      const dayInput = document.getElementById("modalDayInput");

      // Hide all inputs first
      yearInput.style.display = "none";
      monthInput.style.display = "none";
      dayInput.style.display = "none";
      inputsContainer.style.display = "none";

      if (selectedPeriod === "recent") {
        return; // No inputs needed for recent
      }

      inputsContainer.style.display = "flex";

      // Set default values to current date ONLY if input is empty
      const now = new Date();

      if (selectedPeriod === "year" || selectedPeriod === "month" || selectedPeriod === "day") {
        yearInput.style.display = "inline-block";
        if (!yearInput.value || yearInput.value === "") {
          yearInput.value = now.getFullYear();
        }
      }
      if (selectedPeriod === "month" || selectedPeriod === "day") {
        monthInput.style.display = "inline-block";
        if (!monthInput.value || monthInput.value === "") {
          monthInput.value = now.getMonth() + 1;
        }
      }
      if (selectedPeriod === "day") {
        dayInput.style.display = "inline-block";
        if (!dayInput.value || dayInput.value === "") {
          dayInput.value = now.getDate();
        }
      }
    }
    
    async function updateModalChartData() {
      if (!currentChartKind) return;

      const selectedPeriod = document.querySelector("input[name=\"chartPeriod\"]:checked")?.value;
      const year = parseInt(document.getElementById("modalYearInput").value) || null;
      const month = parseInt(document.getElementById("modalMonthInput").value) || null;
      const day = parseInt(document.getElementById("modalDayInput").value) || null;

      // Validate date inputs
      if (selectedPeriod !== "recent") {
        // Validate day for the selected month (silently handle invalid dates)
        if (year && month && day) {
          const daysInMonth = new Date(year, month, 0).getDate();
          if (day > daysInMonth) {
            console.warn(`Invalid date: day ${day} exceeds ${daysInMonth} days in month ${month}`);
            return;
          }
        }

        // Validate year range (silently handle invalid years)
        if (year && (year < 2020 || year > new Date().getFullYear())) {
          console.warn(`Year ${year} out of range (2020-${new Date().getFullYear()})`);
          return;
        }
      }

      try {
        let query = "";
        let dataKey = "";

        // Map metric type to correct currentData field
        const dataFieldMap = {
          'temperature': 'history',
          'temp': 'history',
          'humidity': 'humidityHistory',
          'pressure': 'pressureHistory',
          'co2': 'airQualityHistory'
        };

        const currentDataField = dataFieldMap[currentChartKind] || 'history';

        // Determine which history query to use based on metric type
        const metricQueries = {
          'temperature': {
            fields: 'temperatureC timestampUnix sensorId',
            yearQuery: 'temperatureHistoryByYear',
            monthQuery: 'temperatureHistoryByMonth',
            dayQuery: 'temperatureHistoryByDay',
            recentQuery: 'temperatureHistory'
          },
          'humidity': {
            fields: 'humidityPercent timestampUnix sensorId',
            yearQuery: 'humidityHistory',
            monthQuery: 'humidityHistory',
            dayQuery: 'humidityHistory',
            recentQuery: 'humidityHistory'
          },
          'pressure': {
            fields: 'pressureHpa timestampUnix sensorId sensorType',
            yearQuery: 'pressureHistory',
            monthQuery: 'pressureHistory',
            dayQuery: 'pressureHistory',
            recentQuery: 'pressureHistory'
          },
          'co2': {
            fields: 'co2Ppm nh3Ppm alcoholPpm aqi status timestampUnix',
            yearQuery: 'airQualityHistory',
            monthQuery: 'airQualityHistory',
            dayQuery: 'airQualityHistory',
            recentQuery: 'airQualityHistory'
          }
        };

        const metricConfig = metricQueries[currentChartKind] || metricQueries['temperature'];

        // Build query
        if (selectedPeriod === "year" && year) {
          dataKey = metricConfig.yearQuery;
          query = `{ ${dataKey}(year: ${year}) { ${metricConfig.fields} } }`;
        } else if (selectedPeriod === "month" && year && month) {
          dataKey = metricConfig.monthQuery;
          query = `{ ${dataKey}(year: ${year}, month: ${month}) { ${metricConfig.fields} } }`;
        } else if (selectedPeriod === "day" && year && month && day) {
          dataKey = metricConfig.dayQuery;
          query = `{ ${dataKey}(year: ${year}, month: ${month}, day: ${day}) { ${metricConfig.fields} } }`;
        } else {
          dataKey = metricConfig.recentQuery;
          query = `{ ${dataKey}(limit: 5000) { ${metricConfig.fields} } }`;
        }

        const response = await graphqlQuery(query);
        if (response.data && response.data[dataKey]) {
          // Temporarily update the CORRECT current data field to refresh the chart
          const originalHistory = currentData[currentDataField];
          currentData[currentDataField] = response.data[dataKey];

          // Update the chart
          const ds = chartDataFor(currentChartKind);

          if (currentModalChart) {
            if (ds.labels.length === 0) {
              // Handle empty data - clear the chart
              currentModalChart.data.labels = [];
              currentModalChart.data.datasets.forEach(dataset => {
                dataset.data = [];
              });
              currentModalChart.update();
              console.warn("No data available for selected period");
            } else {
              // Update with new data
              currentModalChart.data = ds;
              currentModalChart.update();
            }
          }

          // Restore original history (so main app data is not affected)
          currentData[currentDataField] = originalHistory;
        } else {
          // No data returned - clear chart
          if (currentModalChart) {
            currentModalChart.data.labels = [];
            currentModalChart.data.datasets.forEach(dataset => {
              dataset.data = [];
            });
            currentModalChart.update();
            console.warn("No data received from query");
          }
        }
      } catch (error) {
        console.error("Error updating modal chart data:", error);
      }
    }
    
    function setupModalEventListeners() {
      // Add event listeners for radio buttons
      document.querySelectorAll("input[name=\"chartPeriod\"]").forEach(radio => {
        radio.addEventListener("change", function() {
          updateModalInputsVisibility();
          updateModalChartData();
        });
      });

      // Add event listeners for input changes
      document.getElementById("modalYearInput").addEventListener("change", updateModalChartData);
      document.getElementById("modalMonthInput").addEventListener("change", updateModalChartData);
      document.getElementById("modalDayInput").addEventListener("change", updateModalChartData);
    }


    async function showMetricChart(kind, mode, anchorEl) {
      await ensureHistory(kind);
      const ds = chartDataFor(kind);
      if (!ds.labels.length) return;

      if (mode === 'modal') {
        currentChartKind = kind;
        const overlay = document.getElementById('chartModalOverlay');
        const title = document.getElementById('chartModalTitle');
        const canvas = document.getElementById('chartModalCanvas');
        // Set professional titles
        const titles = {
          'temp': 'Temperature History',
          'humidity': 'Humidity History',
          'pressure': 'Atmospheric Pressure History',
          'co2': 'Air Quality History',
          'meter': 'Electricity Consumption History'
        };
        title.textContent = titles[kind] || kind.toUpperCase() + ' History';

        if (kind === 'co2') {
          document.getElementById('airQualityInfo').style.display = 'block';
        } else {
          document.getElementById('airQualityInfo').style.display = 'none';
        }
        overlay.style.display = 'flex';

        // Set default to "Months" with current month
        document.getElementById('periodMonth').checked = true;

        // Set inputs to current month
        const now = new Date();
        document.getElementById('modalYearInput').value = now.getFullYear();
        document.getElementById('modalMonthInput').value = now.getMonth() + 1;
        document.getElementById('modalDayInput').value = now.getDate();

        updateModalInputsVisibility();

        if (modalChart) { modalChart.destroy(); }
        modalChart = new Chart(canvas.getContext('2d'), { type: 'line', data: ds, options: buildLineOptions(kind) });
        currentModalChart = modalChart;

        // Load current month's data
        await updateModalChartData();
        
        // Setup event listeners if not already done
        if (!overlay.hasAttribute('data-listeners-setup')) {
          setupModalEventListeners();
          overlay.setAttribute('data-listeners-setup', 'true');
        }
      } else if (mode === 'hover') {
        const pop = document.getElementById('hoverPopover');
        const title = document.getElementById('hoverPopoverTitle');
        const canvas = document.getElementById('hoverPopoverCanvas');
        title.textContent = kind.toUpperCase() + ' History';
        // Position near anchor
        const r = anchorEl.getBoundingClientRect();
        const w = pop.offsetWidth || 320; const h = pop.offsetHeight || 200;
        let top = r.top - h - 8; if (top < 8) top = r.bottom + 8;
        let left = r.left + (r.width/2) - (w/2); left = Math.max(8, Math.min(left, (window.innerWidth - w - 8)));
        pop.style.top = top + 'px'; pop.style.left = left + 'px';
        pop.style.display = 'block';
        if (popoverChart) { popoverChart.destroy(); }
        popoverChart = new Chart(canvas.getContext('2d'), { type: 'line', data: ds, options: buildLineOptions(kind) });
      }
    }

    function hideHoverPopoverSoon() {
      const pop = document.getElementById('hoverPopover');
      if (hoverHideTimer) clearTimeout(hoverHideTimer);
      hoverHideTimer = setTimeout(()=>{ pop.style.display = 'none'; if (popoverChart) { popoverChart.destroy(); popoverChart = null; } }, 250);
    }


    // Attach listeners once DOM is ready
    (function attachChartListeners(){
      function attach(id, kind) {
        const valEl = document.getElementById(id); if (!valEl) return;
        const card = valEl.closest('.metric-card'); if (!card) return;
        card.style.cursor = 'pointer';
        // hover disabled
        // hover disabled
        card.addEventListener('click', ()=> showMetricChart(kind, 'modal', card));
      }
      attach('currentTemp','temp');
      attach('currentPressure','pressure');
      attach('currentHumidity','humidity');
      attach('currentCO2','co2');
      attach('currentMeterReading','meter');

      // Modal close handlers
      const overlay = document.getElementById('chartModalOverlay');
      const closeBtn = document.getElementById('chartModalClose');
      if (overlay) overlay.addEventListener('click', (e)=>{ if (e.target === overlay) { overlay.style.display = 'none'; if (modalChart) { modalChart.destroy(); modalChart = null; } currentChartKind = null; currentModalChart = null; } });
      if (closeBtn) closeBtn.addEventListener('click', ()=>{ overlay.style.display = 'none'; if (modalChart) { modalChart.destroy(); modalChart = null; } currentChartKind = null; currentModalChart = null; });
    })();
    // === End popup charts ===

  </script>
</body>
</html>
