"""
Optimized GraphQL + SSE Flask application for aWeatherStation monitoring system.

Features:
- GraphQL API using pure graphene
- Server-Sent Events for real-time updates (ONLY when temperature changes)
- Temperature data collection service with change detection
"""

import os
import sys
import json
import time
import logging
import argparse
from datetime import datetime, timezone
from typing import Dict, Any, List
from queue import Queue
import threading

from flask import Flask, request, jsonify, Response, send_from_directory
from flask_cors import CORS
from apscheduler.schedulers.background import BackgroundScheduler
from graphql import build_schema, graphql_sync
from graphql.execution import ExecutionResult

import graphene
from graphene import ObjectType, String, Float, List as GrapheneList, Field, Int, Schema

# Import our modules
from models import init_database, db, TemperatureReading as DBTemperatureReading, HumidityReading as DBHumidityReading
from sensor_reader import TemperatureSensorReader, HumiditySensorReader

# Configure logging
logging.basicConfig(
    level=logging.ERROR,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/backend.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Flask application setup
app = Flask(__name__)
app.config['SECRET_KEY'] = 'temperature-monitoring-graphql-2025'

# Enable CORS
CORS(app, resources={
    r"/*": {
        "origins": "*",
        "methods": ["GET", "POST", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization", "Cache-Control"]
    }
})

# Global variables
temperature_sensor = None
scheduler = None
sse_clients = Queue()


# GraphQL Types (same as before)
class TemperatureReading(ObjectType):
    id = Int()
    temperature_c = Float()
    timestamp = String()
    timestamp_unix = Float()
    sensor_type = String()
    sensor_id = String()


class TemperatureStatistics(ObjectType):
    count = Int()
    average = Float()
    minimum = Float()
    maximum = Float()
    hours_back = Int()




class HumidityReading(ObjectType):
    id = Int()
    humidity_percent = Float()
    timestamp = String()
    timestamp_unix = Float()
    sensor_type = String()
    sensor_id = String()


class HumidityStatistics(ObjectType):
    count = Int()
    average = Float()
    minimum = Float()
    maximum = Float()
    hours_back = Int()

class SensorInfo(ObjectType):
    sensor_type = String()
    sensor_id = String()
    initialized = String()
    active_sensor = String()


class HealthStatus(ObjectType):
    status = String()
    timestamp = String()
    database = String()
    sensor = Field(SensorInfo)
    recent_readings = Int()


# GraphQL Queries
class Query(ObjectType):
    health = Field(HealthStatus)
    current_temperature = Field(TemperatureReading)
    temperature_history = GrapheneList(
        TemperatureReading,
        range=String(default_value="daily"),
        limit=Int(default_value=1000)
    )
    temperature_statistics = Field(
        TemperatureStatistics,
        hours=Int(default_value=24)
    )
    sensor_info = Field(SensorInfo)

    # Humidity queries
    current_humidity = Field(HumidityReading)
    humidity_history = GrapheneList(
        HumidityReading,
        range=String(default_value="daily"),
        limit=Int(default_value=1000)
    )
    humidity_statistics = Field(
        HumidityStatistics,
        hours=Int(default_value=24)
    )

    def resolve_health(self, info):
        try:
            stats = db.get_statistics(hours_back=1)
            sensor_info_dict = temperature_sensor.get_sensor_info() if temperature_sensor else {}
            
            return HealthStatus(
                status="ok",
                timestamp=datetime.now(timezone.utc).isoformat(),
                database="connected",
                sensor=SensorInfo(
                    sensor_type=sensor_info_dict.get('sensor_type', 'unknown'),
                    sensor_id=sensor_info_dict.get('active_sensor', {}).get('type', 'unknown'),
                    initialized="true" if sensor_info_dict.get('initialized') else "false",
                    active_sensor=str(sensor_info_dict.get('active_sensor', {}))
                ),
                recent_readings=stats.get('count', 0)
            )
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return HealthStatus(
                status="error",
                timestamp=datetime.now(timezone.utc).isoformat(),
                database="error",
                sensor=None,
                recent_readings=0
            )

    def resolve_current_temperature(self, info):
        try:
            recent_readings = db.get_recent_readings(limit=1)
            if not recent_readings:
                return None
                
            reading = recent_readings[0]
            return TemperatureReading(
                id=reading.id,
                temperature_c=reading.temperature_c,
                timestamp=reading.timestamp.isoformat(),
                timestamp_unix=reading.timestamp.timestamp(),
                sensor_type=reading.sensor_type,
                sensor_id=reading.sensor_id
            )
        except Exception as e:
            logger.error(f"Error getting current temperature: {e}")
            return None

    def resolve_temperature_history(self, info, range="daily", limit=1000):
        try:
            limit = min(limit, 5000)
            
            if range == "daily":
                readings = db.get_daily_readings(days_back=1)
            elif range == "weekly":
                readings = db.get_weekly_readings(weeks_back=1)
            elif range == "recent":
                readings = db.get_recent_readings(limit=limit)
            else:
                readings = db.get_recent_readings(limit=limit)
                
            result = []
            for reading in readings[:limit]:
                result.append(TemperatureReading(
                    id=reading.id,
                    temperature_c=reading.temperature_c,
                    timestamp=reading.timestamp.isoformat(),
                    timestamp_unix=reading.timestamp.timestamp(),
                    sensor_type=reading.sensor_type,
                    sensor_id=reading.sensor_id
                ))
                
            result.sort(key=lambda x: x.timestamp_unix)
            return result
            
        except Exception as e:
            logger.error(f"Error getting temperature history: {e}")
            return []

    def resolve_temperature_statistics(self, info, hours=24):
        try:
            stats = db.get_statistics(hours_back=hours)
            return TemperatureStatistics(
                count=stats['count'],
                average=stats['average'],
                minimum=stats['minimum'],
                maximum=stats['maximum'],
                hours_back=stats['hours_back']
            )
        except Exception as e:
            logger.error(f"Error getting temperature statistics: {e}")
            return TemperatureStatistics(
                count=0, average=0.0, minimum=0.0, maximum=0.0, hours_back=hours
            )

    def resolve_sensor_info(self, info):
        try:
            if temperature_sensor:
                sensor_info_dict = temperature_sensor.get_sensor_info()
                return SensorInfo(
                    sensor_type=sensor_info_dict.get('sensor_type', 'unknown'),
                    sensor_id=sensor_info_dict.get('active_sensor', {}).get('type', 'unknown'),
                    initialized="true" if sensor_info_dict.get('initialized') else "false",
                    active_sensor=str(sensor_info_dict.get('active_sensor', {}))
                )
            return None
        except Exception as e:
            logger.error(f"Error getting sensor info: {e}")
            return None



    # Humidity resolvers
    def resolve_current_humidity(self, info):
        try:
            recent_readings = db.get_recent_humidity_readings(limit=1)
            if not recent_readings:
                return None
                
            reading = recent_readings[0]
            return HumidityReading(
                id=reading.id,
                humidity_percent=reading.humidity_percent,
                timestamp=reading.timestamp.isoformat(),
                timestamp_unix=reading.timestamp.timestamp(),
                sensor_type=reading.sensor_type,
                sensor_id=reading.sensor_id
            )
        except Exception as e:
            logger.error(f'Error getting current humidity: {e}')
            return None
            
    def resolve_humidity_history(self, info, range='daily', limit=1000):
        try:
            if range == 'recent':
                readings = db.get_recent_humidity_readings(limit=limit)
            elif range == 'daily':
                readings = db.get_recent_humidity_readings(limit=min(limit, 1440))  # Max 1 day of minute readings
            elif range == 'weekly':
                readings = db.get_recent_humidity_readings(limit=min(limit, 10080))  # Max 1 week of minute readings
            else:
                readings = db.get_recent_humidity_readings(limit=limit)
                
            return [
                HumidityReading(
                    id=reading.id,
                    humidity_percent=reading.humidity_percent,
                    timestamp=reading.timestamp.isoformat(),
                    timestamp_unix=reading.timestamp.timestamp(),
                    sensor_type=reading.sensor_type,
                    sensor_id=reading.sensor_id
                )
                for reading in readings
            ]
        except Exception as e:
            logger.error(f'Error getting humidity history: {e}')
            return []
            
    def resolve_humidity_statistics(self, info, hours=24):
        try:
            stats = db.get_humidity_statistics(hours_back=hours)
            
            if stats.get('count', 0) > 0:
                return HumidityStatistics(
                    count=stats['count'],
                    average=round(stats['avg'], 2),
                    minimum=stats['min'],
                    maximum=stats['max'],
                    hours_back=hours
                )
            return HumidityStatistics(
                count=0, average=0.0, minimum=0.0, maximum=0.0, hours_back=hours
            )
        except Exception as e:
            logger.error(f'Error getting humidity statistics: {e}')
            return HumidityStatistics(
                count=0, average=0.0, minimum=0.0, maximum=0.0, hours_back=hours
            )


# GraphQL Schema
schema = Schema(query=Query)


# Weather Station Collector - Sends SSE updates every second
class WeatherStationCollector:
    def __init__(self, temperature_sensor: TemperatureSensorReader, humidity_sensor: HumiditySensorReader = None):
        self.temperature_sensor = temperature_sensor
        self.humidity_sensor = humidity_sensor
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self.last_reading = None
        self.last_temperature = None  # Track previous temperature
        self.last_humidity = None    # Track previous humidity
        self.error_count = 0
        self.max_errors = 10
        self.temperature_threshold = 0.1  # Only send SSE if change >= 0.1°C
        self.max_time_between_updates = 30  # Send update at least every 30 seconds
        self.last_sse_time = time.time()
        
    def collect_temperature(self):
        try:
            reading = self.temperature_sensor.get_reading()
            
            if reading is None:
                self.error_count += 1
                self.logger.warning(f"Failed to read temperature (error count: {self.error_count})")
                
                if self.error_count >= self.max_errors and self.temperature_sensor.sensor_type != "mock":
                    self.logger.error("Too many sensor errors, switching to mock sensor")
                    self.temperature_sensor = TemperatureSensorReader("mock")
                    self.error_count = 0
                return
                
            self.error_count = 0
            current_temp = reading.temperature_c
            current_time = time.time()
            
            # Always store in database
            db_reading = db.add_temperature_reading(
                temperature_c=current_temp,
                sensor_type=reading.sensor_type,
                sensor_id=reading.sensor_id,
                timestamp=datetime.fromtimestamp(reading.timestamp, tz=timezone.utc)
            )
            
            if not db_reading:
                self.logger.error("Failed to store temperature reading in database")
                # Continue anyway to send SSE updates
            
            # SMART SSE: Only send when temperature changes significantly OR after max time
            should_send_sse = False
            send_reason = ""
            
            # Always send SSE updates every second
            should_send_sse = True
            if self.last_temperature is None:
                send_reason = "first_reading"
            elif abs(current_temp - self.last_temperature) >= self.temperature_threshold:
                send_reason = f"temp_change_{abs(current_temp - self.last_temperature):.2f}°C"
            else:
                send_reason = "regular_update"
            
            if should_send_sse:
                temperature_data = {
                    'type': 'temperature_update',
                    'data': {
                        'temperature_c': round(current_temp, 2),
                        'timestamp': reading.timestamp,
                        'timestamp_iso': datetime.fromtimestamp(reading.timestamp, tz=timezone.utc).isoformat(),
                        'sensor_type': reading.sensor_type,
                        'sensor_id': reading.sensor_id,
                        'change_reason': send_reason,  # Debug info
                        'previous_temp': self.last_temperature
                    }
                }
                
                try:
                    sse_clients.put_nowait(temperature_data)
                    self.last_sse_time = current_time
                    self.logger.info(f"SSE sent: {current_temp:.2f}°C (reason: {send_reason})")
                except:
                    pass  # Queue full
            else:
                self.logger.debug(f"SSE skipped: {current_temp:.2f}°C (no significant change)")
            
            self.last_temperature = current_temp
            self.last_reading = reading
            
        except Exception as e:
            self.error_count += 1
            self.logger.error(f"Error in temperature collection: {e}")


    def collect_humidity(self):
        """Collect humidity data and store in database."""
        try:
            if not self.humidity_sensor:
                return  # No humidity sensor configured
                
            current_humidity = self.humidity_sensor.get_current_humidity()
            
            if current_humidity is None:
                self.logger.warning("Failed to read humidity")
                return
                
            # Always store in database
            db_reading = db.add_humidity_reading(
                humidity_percent=current_humidity,
                sensor_type=self.humidity_sensor.sensor_type,
                sensor_id="default"
            )
            
            if not db_reading:
                self.logger.error("Failed to store humidity reading in database")
                # Continue anyway to send SSE updates
            
            # Always send SSE updates for humidity every second
            current_time = time.time()
            should_send_sse = True
            
            if should_send_sse:
                humidity_data = {
                    'type': 'humidity_update',
                    'humidity_percent': current_humidity,
                    'timestamp': datetime.now(timezone.utc).isoformat(),
                    'sensor_type': self.humidity_sensor.sensor_type,
                    'sensor_id': 'default'
                }
                
                sse_clients.put_nowait(humidity_data)
                self.last_humidity = current_humidity
                self.last_sse_time = current_time
                
        except Exception as e:
            self.logger.error(f"Error in humidity collection: {e}")
    
    def collect_all_data(self):
        """Collect both temperature and humidity data."""
        self.collect_temperature()
        self.collect_humidity()


# GraphQL endpoint
@app.route('/graphql', methods=['POST'])
def graphql_endpoint():
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No JSON data provided'}), 400
            
        query = data.get('query')
        variables = data.get('variables', {})
        
        if not query:
            return jsonify({'error': 'No query provided'}), 400
        
        # Execute GraphQL query
        result = schema.execute(query, variables=variables)
        
        response_data = {'data': result.data}
        if result.errors:
            response_data['errors'] = [str(error) for error in result.errors]
            
        return jsonify(response_data)
        
    except Exception as e:
        logger.error(f"GraphQL endpoint error: {e}")
        return jsonify({'error': 'Internal server error'}), 500


# GraphiQL interface for development
@app.route('/graphql', methods=['GET'])
def graphiql():
    return '''
    <!DOCTYPE html>
    <html>
    <head>
        <title>GraphiQL</title>
        <link href="https://unpkg.com/graphiql@1.4.7/graphiql.min.css" rel="stylesheet" />
    </head>
    <body style="margin: 0;">
        <div id="graphiql" style="height: 100vh;"></div>
        <script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
        <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
        <script crossorigin src="https://unpkg.com/graphiql@1.4.7/graphiql.min.js"></script>
        <script>
            const fetcher = (graphQLParams) =>
                fetch('/graphql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(graphQLParams),
                })
                .then(response => response.json());

            ReactDOM.render(
                React.createElement(GraphiQL, { fetcher }),
                document.getElementById('graphiql')
            );
        </script>
    </body>
    </html>
    '''


# Server-Sent Events (optimized)
@app.route('/events')
def events():
    def event_stream():
        # Send immediate connection confirmation with latest data
        yield f"data: {json.dumps({'type': 'connected', 'timestamp': time.time()})}\n\n"
        
        # Immediately send latest temperature from database
        try:
            with db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT temperature_c, timestamp, sensor_type, sensor_id FROM temperature_readings ORDER BY timestamp DESC LIMIT 1")
                temp_row = cursor.fetchone()
                if temp_row:
                    temp_data = {
                        'temperature_c': temp_row[0],
                        'timestamp_iso': temp_row[1],
                        'sensor_type': temp_row[2],
                        'sensor_id': temp_row[3]
                    }
                    sse_message = {
                        'type': 'temperature_update',
                        'data': temp_data,
                        'timestamp': temp_row[1]
                    }
                    yield f"data: {json.dumps(sse_message)}\n\n"
                
                # Also send latest humidity
                cursor.execute("SELECT humidity_percent, timestamp FROM humidity_readings ORDER BY timestamp DESC LIMIT 1")
                humidity_row = cursor.fetchone()
                if humidity_row:
                    humidity_data = {
                        'humidity_percent': humidity_row[0],
                        'timestamp_iso': humidity_row[1],
                        'sensor_type': 'mock',
                        'sensor_id': 'default'
                    }
                    sse_message = {
                        'type': 'humidity_update',
                        'humidity_percent': humidity_row[0],
                        'timestamp': humidity_row[1],
                        'sensor_type': 'mock',
                        'sensor_id': 'default'
                    }
                    yield f"data: {json.dumps(sse_message)}\n\n"
        except Exception as e:
            print(f"Error sending initial data: {e}")
        
        while True:
            try:
                data = sse_clients.get(timeout=5)  # Much shorter timeout
                yield f"data: {json.dumps(data)}\n\n"
                sse_clients.task_done()
            except:
                # Send heartbeat to keep connection alive
                yield f"data: {json.dumps({'type': 'heartbeat', 'timestamp': time.time()})}\n\n"
    
    return Response(
        event_stream(),
        mimetype='text/event-stream',
        headers={
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Cache-Control'
        }
    )


# Static file serving
@app.route('/')
def serve_frontend():
    frontend_path = os.path.join(os.path.dirname(__file__), '..', 'frontend')
    return send_from_directory(frontend_path, 'index.html')


@app.route('/<path:filename>')
def serve_static(filename):
    frontend_path = os.path.join(os.path.dirname(__file__), '..', 'frontend')
    return send_from_directory(frontend_path, filename)


def initialize_application():
    global temperature_sensor, humidity_sensor, scheduler
    
    try:
        logger.info("Initializing database...")
        init_database()
        
        logger.info("Initializing temperature sensor...")
        temperature_sensor = TemperatureSensorReader()
        sensor_info = temperature_sensor.get_sensor_info()
        logger.info(f"Temperature sensor initialized: {sensor_info}")
        
        logger.info("Initializing humidity sensor...")
        humidity_sensor = HumiditySensorReader()
        humidity_info = humidity_sensor.get_sensor_info()
        logger.info(f"Humidity sensor initialized: {humidity_info}")
        
        # Use the SMART collector with both sensors
        collector = WeatherStationCollector(temperature_sensor, humidity_sensor)
        
        logger.info("Setting up SMART temperature collection scheduler...")
        scheduler = BackgroundScheduler(daemon=True)
        scheduler.add_job(
            func=collector.collect_all_data,
            trigger='interval',
            seconds=300,  # Collect every 5 minutes
            id='smart_temperature_collection'
        )
        scheduler.start()
        logger.info("SMART temperature collection scheduler started")
        logger.info("SSE will send temperature updates every 5 minutes")
        
        collector.collect_all_data()
        return True
        
    except Exception as e:
        logger.error(f"Failed to initialize application: {e}")
        return False


def cleanup_application():
    global scheduler
    
    logger.info("Cleaning up application...")
    
    if scheduler:
        scheduler.shutdown()
        logger.info("Scheduler shutdown complete")
        
    if db:
        db.close()
        logger.info("Database connections closed")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='aWeatherStation GraphQL monitoring server (OPTIMIZED)')
    parser.add_argument('--host', default='0.0.0.0', help='Host to bind to')
    parser.add_argument('--port', type=int, default=5000, help='Port to listen on')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    parser.add_argument('--threshold', type=float, default=0.1, help='Temperature change threshold for SSE (default: 0.1°C)')
    parser.add_argument('--heartbeat', type=int, default=30, help='Max seconds between SSE updates (default: 30)')
    
    args = parser.parse_args()
    
    try:
        if not initialize_application():
            logger.error("Failed to initialize application")
            sys.exit(1)
            
        logger.info(f"Starting OPTIMIZED aWeatherStation GraphQL server on {args.host}:{args.port}")
        logger.info("GraphQL endpoint: http://192.168.50.2:5000/graphql")
        logger.info("SSE endpoint: http://192.168.50.2:5000/events")
        logger.info(f"SSE optimization: Updates only when temp changes >= {args.threshold}°C")
        logger.info("Press Ctrl+C to stop the server")
        
        app.run(
            host=args.host,
            port=args.port,
            debug=args.debug,
            use_reloader=False,
            threaded=True
        )
        
    except KeyboardInterrupt:
        logger.info("Server interrupted by user")
    except Exception as e:
        logger.error(f"Server error: {e}")
        sys.exit(1)
    finally:
        cleanup_application()
